{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<p> Welcome to the Virginia Tech Sailbot and PEP Documentation!</p>","text":"<p>This document will outline how to set up the software stack on theoretically any modern computer. For more information on how to run simulations, testing, and how to run this code on the jetson, please refer to the other docs.</p> <p></p>"},{"location":"#what-is-the-purpose-of-this-document","title":"<p> What Is the Purpose of This Document? </p>","text":"<p>The purpose of this document is to be an installation guide, overview of all of the technologies that we use, a description of how the software works, and a guide to how to use the software all in one! This is basically, in professional terms, an ICD, and the upkeep of this document is of paramount importance as this is the best and most efficient way to facilitate knowledge transfer between senior members of the club and newer members.</p> <p></p>"},{"location":"#how-do-i-get-started","title":"<p> How Do I Get Started? </p>","text":"<p>Head over to the Getting Started part of the documentation and complete the installation steps over at Installing Docker to install Docker. Then, complete the installation steps found in Setting Up the Development Container, and once you have the development container all set up, you should be ready to test everything! To get a simple simulation scenario up and running, then please visit Examples. </p> <p></p>"},{"location":"#what-frameworks-should-i-learn","title":"<p> What Frameworks Should I Learn? </p>","text":"<p>ROS2: Our techstack utilizes ROS2 (The Robotics Operating System) at its core. Unlike its name implies, it is not an actual operating system, but rather a middleware wrapper that makes concurrency and communication between sensor, actuators, autopilots, and telemetry super easy! This is the industry standard for projects just like this one so if you ever want to do anything in robotics, then this is the framework to learn! The specific version we are using is ROS2 Humble Hawksbill or ROS2 Humble for short, and the documentation for it can be found right here: ROS2 Humble Documentation. Specifically, I would recommend heading to the Tutorials and Concepts sections as those are the most useful for beginners. In addition, there is a really good video series outlining how to get started and do stuff with ROS in addition to the concepts, which can be found here: ROS2 Tutorial Series EP1.</p> <p>Docker: While this isn't much of a framework, it is still an important tool and understanding how it works and the concepts behind it, will make troubleshooting if you ever run into problems a bit easier. Docker is seen pretty much everywhere in software nowadays because its a super streamlined and fast way to create custom virtual machines. It really doesn't matter which part of the software industry you would like to work in in the future, I guarantee you that you will run into docker into some point. So it's better to learn it sooner rather than later! Heres some links to documentation and videos - Docker Overview - Docker Video Explanation 1 - Docker Video Explanation 2  It turns out that Docker can be used for more than just deployment though. Relatively recently, Docker introduced full support for something called Docker Development Environments (Or Docker Development Containers), which allows us to do all of our development through a Docker container right inside VSCode! Thats great because getting ROS2 and our entire project working on everyone's computers and operating systems was a nightmare to orchestrate and setup, now everyone can just install Docker and our custom development container and start developing instantly! Additionally, there are plenty of other IDEs that support integration with development containers in case you use something other than VSCode; however, VSCode is what we will focus on in this document's setup instructions.</p>"},{"location":"examples/running_individual_nodes/","title":"Running Individual Nodes for Testing","text":"<p>Sometimes it may be preferable to run each node in a separate terminal, so that you can get cleaner debug messages. If you would like to do this, then all of the commands to run each individual node are included in the documentation for that node.</p>"},{"location":"examples/running_simulation/","title":"Running the Simulation","text":"<p>To run the simulation, all you need to do is run the following command:</p> <p><code>ros2 launch /home/ws/src/launch/simulation.launch.py</code></p> <p>This command will then start the simulation and autopilot. Initially, however they won't do anything because they don't have any waypoint commands, so what you will need to do is go into your ground station folder in another terminal (not in the dev container) and type in the following command:  </p> <p><code>python send_desired_parameters_and_waypoints.py</code></p> <p>Doing this should make the boat in the visualization move around the pop up screen!  </p> <p>The boat might be kind of slow though, so be sure to go check out how to run a custom simulation in the examples. With the custom simulations we can accelerate the speed of the simulation by a landslide!</p>"},{"location":"getting_started/installing_docker/","title":"Installing Docker","text":"<p>NOTE: If You Meet Dificulties Installing Docker</p> <p>Ensure that you meet the docker's system requirements listed on their documentation, if not then attempt to contact an officer or look through the docker documentation for what to do if you do not meet the system requirements. Heres the link to the Docker documentation Docker Documentation</p>"},{"location":"getting_started/installing_docker/#installing-docker-on-windows","title":"<p> Installing Docker on Windows </p>","text":"<p>In order to install Docker on windows, first we must install WSL (Windows Subsystem in Linux).  </p> <p>Open the command prompt with administrator privileges and type the following commands <pre><code>wsl.exe --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> Enter your user info to complete the installation  </p> <p>With these steps, this will have installed WSL and Ubuntu 22.04. Docker requires Ubuntu WSL to work on Windows.  For more information see the official WSL documentation:  Official WSL Documentation</p> <p>Next, we must install the docker desktop application and connect it up to WSL.</p> <p>The following link contains the download link for docker desktop on windows.  Follow the download instructions, and when you are done, you should have docker installed! Docker Desktop for Windows Install Page </p> <p>You may run into permission issues with docker, so you need to run the following commands in your WSL terminal to give your non-sudo user access to docker. <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre></p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-ubuntu-linux","title":"<p> Installing Docker on Ubuntu Linux </p>","text":"<p>Please type the following sets of commands in a terminal. <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <pre><code># Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre></p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-mac-os","title":"<p> Installing Docker on Mac OS</p>","text":"<p>Please follow the official docker installation instructions as I am not too familiar with Mac computers. However if you own a Mac and would like to contribute to the documentation by writing up explicit installation instructions for Mac, please feel free. Official Docker Installation Instruction Mac</p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-other-operating-systems","title":"<p> Installing Docker on Other Operating Systems </p>","text":"<p>Documentation for the rest of the operating systems docker supports can be found here: Official Docker Installation Instructions for Every OS.</p>"},{"location":"getting_started/setting_up_dev_environment/","title":"<p> Before Setting Up the Dev Environment </p>","text":"<p>Make sure that you have installed docker before doing this step. The following steps will not work if docker is not installed on your machine. The easiest way to check whether docker is installed correctly, open a terminal and type <code>docker</code>. If an error doesn't pop up that means that you can proceed!</p> <p>Also ensure that you have VSCode or some other IDE that supports Docker dev environments installed (If you are using Windows you install VSCode in WSL too). For the purposes of this documentation, we will be using VSCode but there are plenty of other IDEs that support this and they each have their own documentation for how to get this setup.</p>"},{"location":"getting_started/setting_up_dev_environment/#installing-the-development-container","title":"<p> Installing the Development Container </p>","text":"<ul> <li>First, (If you are using Windows you must do this in a WSL folder) we need to clone the main github repository from the following URL: https://github.com/sailbot-vt/sailbot_vt. Open up a terminal and type the following command: <code>git clone https://github.com/sailbot-vt/sailbot_vt</code></li> <li>Then, open up that folder in VSCode by typing the following into the same terminal: <code>cd sailbot_vt &amp;&amp; code .</code></li> <li>Install the Docker Dev Containers Extension on VSCode. It should look like the following: </li> <li>Build and enter dev container for the repo by typing in the following into the search bar at the top <code>&gt;dev containers build</code>. You should see something similar to this at the top: . Wait for a moment as the container sets itself up!</li> </ul>"},{"location":"getting_started/setting_up_dev_environment/#final-setup-after-loading-development-container","title":"<p> Final Setup after Loading Development Container </p>","text":"<p>Once you are inside your development container, go to the terminal and input the following commands. <pre><code>bash docker_dev_environment_setup.sh\n</code></pre> <pre><code>source ~/.bashrc\n</code></pre> Restart VSCode by closing it and reopening it to make sure all of the changes refresh properly  </p>"},{"location":"getting_started/setting_up_dev_environment/#connecting-back-to-the-dev-container","title":"<p> Connecting Back to The Dev Container </p>","text":"<p>If you would like to close the container and resume development on it some other time then heres how you do that. First, open a VSCode window and click on the search bar at the very top. Instead of searching like you would normally, instead type <code>&gt;open folder in container</code>. Remember to include the \"&gt;\" as thats what allows your VSCode search bar to run commands. Once you do that you should get a popup that looks something like this  Click on Dev Containers: Open Folder in Container. This should navigate you to a file explorer. Using it, simply navigate to the folder that you cloned the github repo into and you should be back to your development container.</p>"},{"location":"getting_started/what_did_you_just_install/","title":"<p> What is Docker and How Does it Work? </p>","text":"<p>Docker is essentially a way to share custom (super fast) virtual machines. A Dockerfile is the instructions to create these virtual machines. These are then compiled into Docker Images which are the virtual machines stopped at whatever point the Dockerfile told it to stop at. When you run a Docker Image, you get a Docker Container. A Docker Container is the actual virtual machine that you can interact with and work with.  </p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-is-a-development-container-and-why-are-we-using-one","title":"<p> What is a Development Container and Why are We Using One? </p>","text":"<p>A Development Container is a just a Docker Container that already has all of the requirements to start developing, so you can skip setup and not worry about operating system specific software. There are a lot of software packages we rely on and some of the software that we use only works on certain versions on Ubuntu and is really hard to get your hands on with other operating systems. Docker Development Containers automate the process of installing everything by creating a Docker Image with everything installed and running that. This allows you to start developing instantely! Additionally this helps automate and streamline deployment on the Nvidia Jetson microprocessor.</p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-about-the-ground-station","title":"<p> What About the Ground Station? </p>","text":"<p>This code is supposed to be run on an operator's computer to control the boat while it is on the water by telling a cloud server what we want our boat to do. The boat (specifically the telemetry node) then listens to this cloud server, processes the data, and performs whatever action we told it to do. You can do various things like sending different parameters to the autopilot and sending waypoints. These parameters can look like the PID gains or the tacking distance or the size of the no go zone etc (in other words things that were chosen arbitrarily).</p> <p>You can also use the ground station code to control the simulation, so if you send waypoints or parameters while a simulation is running then the simulation will automatically listen to the cloud server and navigate to those waypoints/ change specific parameters.</p> <p>As of right now the code is kind of a mess and the visualization barely works (one of the big things we are trying to do is have an actual ground station app ready by this year's competition) The primary files you should care about in the groundstation are the following files: desired_parameters.json, desired_waypoints.json, send_desired_parameters_and_waypoints.py, and main.py (although main.py is kind of a mess right now). </p> <p>The essential functionality is that send_desired_parameters_and_waypoints.py just sends the data from desired_parameters.json and desired_waypoints.json and you can edit those based on what you want to change. Waypoints are simply supplied as a list of [latitude, longitude] (TODO maybe add a picture here). The list of parameters that you can change are found in the autopilot node here: config/default_parameters.yaml</p> <p>For more information on how the ground station sends parameters, please see the resources section of the documentation.  </p>"},{"location":"misc/known_issues/","title":"Known Issues:","text":"<ul> <li>In order to get full intellisense, you need to restart the dev container after building it. Idk how to fix this man but just go with it. The issue might be that the docker dev environment doesn't register the .vscode folder when it first starts up which is interesting... not sure how I would go about fixing it if thats the issue.</li> </ul>"},{"location":"misc/potential_security_risks/","title":"Heres where I put potential security risks which don't matter at all right now but may matter in the future.","text":"<p>In the future though if we ever want to open source this and release it as a tool for others to use or a product, this would be where to start. - dev container uses docker.sock which needs to have permissions granted to it. So I just do it through ~/.bashrc - <code>sailbot_user ALL=(ALL) NOPASSWD: chmod</code> is appended to /etc/sudoers when building the image. This is not the safest lol</p> <p>Please contact chris (animated__ through discord) if you want to change these things but don't know if we are at a stage where you should/ how to do it</p>"},{"location":"misc/todo/","title":"<p> TODO </p>","text":"<p>We use todoist to manage all of our current projects and planning.  If you would like to see what we are currently working on then please visit the following link</p>"},{"location":"misc/todo/#add-the-following-aliases-if-they-help","title":"Add the following aliases if they help:","text":"<ul> <li>alias python=python3</li> <li>alias 'colcon build'='cd /home/ws &amp;&amp; colcon build'</li> </ul>"},{"location":"nodes/autopilot/","title":"<p> Autopilot </p>","text":""},{"location":"nodes/autopilot/#summary","title":"Summary","text":"<p>This node is responsible for listening to data about the current state of the boat and a set of waypoints and publishing the desired rudder and sail angles based on our autopilot software. This node runs completely asynchronously on an internal timer, which means that a few times every seconds it runs a non-blocking script to calculate what the desired rudder and sail angles should be and publishes them when its done.</p> <p>Additionally, this node publishes data that is useful for telemetry and debugging such as the the current maneuver it is attempting to perform and what its desired heading is currently.</p> <p>An important thing to note is that this node also controls basic RC override, which is why it needs to listen into the raw RC data. There are several different types of RC override listed below:  TODO: make this actually documented lol</p> <p></p>"},{"location":"nodes/autopilot/#the-autopilot-parameters-system","title":"The Autopilot Parameters System","text":"<p>In order for us to be able to control and tune parameters for the autopilot from the groundstation, this node also listens for autopilot_parameters. These are jsons (serialized as strings) which detail all of the new parameters and what their values should be. These values are sent from the groundstation to the telemetry server, then to the telemetry node and then finally to the autopilot. An example of these parameters is shown below:  </p> <p>Not all of the parameters need to be included in the json. If only some of the parameters are included, then only those parameters will get changed in the autopilot.</p> <p></p>"},{"location":"nodes/autopilot/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run autopilot autopilot\n</code></pre>"},{"location":"nodes/autopilot/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> <li>/heading (Float32 from std_msgs)</li> <li>/apparent_wind_vector (Vector3 from geometry_msgs)</li> <li>/autopilot_parameters (String from std_msgs)</li> <li>/rc_data (RCData from sailbot_msgs)</li> <li>/autopilot_mode (String from std_msgs)</li> <li>/waypoints_list (WaypointList from sailbot_msgs)</li> </ul>"},{"location":"nodes/autopilot/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/full_autonomy_maneuver (String from std_msgs)</li> <li>/desired_heading (Float32 from std_msgs)</li> <li>/actions/sail_angle (Float32 from std_msgs)</li> <li>/actions/rudder_angle (Float32 from std_msgs)</li> </ul>"},{"location":"nodes/compass/","title":"<p> Compass </p>","text":""},{"location":"nodes/compass/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our tilt-compensating compass (CMPS14) which give us data on where our current heading is. We employ various filtration techniques to ensure that the data we get back contains as little noise as possible.</p> <p>Since our compass can only communicate through I2C, we created a ustom I2C to USB UART converter out of a spare arduino nano (its surprisingly hard to find good ones of these off of Amazon). The code for this converter is found in the arduino repository.</p> <p>TODO: add an explanation of our custom communication protocol here!</p> <p>Side Note: Funny story, at the 2024 Sailbot competition, we were scrambling because our compass didn't work. We didn't have time to fully integration test as a team because the hull got finished super late into the school year and by the time we were ready to integration test Chris had already left back home, so we were forced to do all of our testing (yes even on-water testing) over teamviewer and discord calls with the MechE lead, Adam, and our Navarch team lead, Michio who had stayed in Blacksburg. That was an interesting time, but the main point is that we hadn't really found the time to make sure the compass worked inside the boat since we had only tested it outside the boat and assumed it would just work. Now I am not naming names, but someone on the Mech team decided to make the mounting bracket for the compass out of metal and put it in a place that was kind of obscured and hard to see/ take out. The first time we went to test our compass was giving us crazy and inconsistant values and we didn't know why. Sometimes it was really right and sometimes it was wrong, so after like 2 days (AT COMP) of trying to debug every point of failure possible, recallibrating, and reflashing the I2C to UART converter, that the issue was the metal bracket, and we eventually had another one 3D printed (thank God we brought our 3D printer lol). Moral of the story, always integration test and never make the compass mounting bracket out of metal!</p>"},{"location":"nodes/compass/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run compass compass\n</code></pre>"},{"location":"nodes/compass/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/heading (Float32 from std_msgs)</li> </ul>"},{"location":"nodes/gps/","title":"<p> GPS </p>","text":""},{"location":"nodes/gps/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our GPS (Sparkfun NEO-M8P-2) and using various filtering techniques to clean the data and make it less noisy. Our GPS gives us both position and velocity data by tracking satellites in the sky, so performance may vary depending on how cloudy it is. </p> <p>We use the sparkfun-ublox-gps pip package to communicate with the gps, although in the future, we could look into the pyubx2 library as that seems to have more features. </p> <p>In the future we may also want to look into RTK (real time kinematics) to increase our GPS accuracy, but even without that, our GPS module is really precise with 0.5 meter accuracy! RTK would be nice though because it allows us to apply less aggressive filtering techniques and still get good results.</p>"},{"location":"nodes/gps/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run gps gps\n</code></pre>"},{"location":"nodes/gps/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> </ul>"},{"location":"nodes/mcu/","title":"<p> MCU (Micro Controller Unit) </p>","text":""},{"location":"nodes/mcu/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our MCU, also known as just micro-controllers. micro-controllers are devices like arduinos that help our jetson communicate with the motors and some very specific sensors on board that we would rather route through the micro-controller (Please refer to the electrical the electrical schematic in for what we are routing through our micro-controller of choice). Primarily, this node's responsibility is to communicate with the MCU through a USB serial connection and whatever format that we decided to send our data in.</p> <p>Side Note: There is an odd story behind us using a microcontroller to speak with everything. A while back (before even Chris's time) we used to control the motors and stuff directly with our on-board computer, but someone fried the on-board computer and ever since we were told to not control motors directly with the on-board computer. Its strange because there should never be a high voltage running through back to the on-board computer, so I don't quite know what happened there. Either way, I like it better this way because it allows us to easily unplug and replug everything into the jetson (since it is all plugged in via USB).</p> <p></p>"},{"location":"nodes/mcu/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run mcu mcu\n</code></pre>"},{"location":"nodes/mcu/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":"<ul> <li>/actions/sail_angle (Float32 from std_msgs)</li> <li>/actions/rudder_angle (Float32 from std_msgs)</li> </ul>"},{"location":"nodes/rc/","title":"<p> RC (Remote Controller) </p>","text":""},{"location":"nodes/rc/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our RC (remote controller). I believe the RC we use is one in the Radiomaster RP series but I am not entirely sure about the specific model since it has been a while since I have looked at it (I'll hopefully update this when school starts again). The communication protocol that we use is called CRSF with ExpressLRS, and we use the crsf_parser pip package to help us parse the crsf frames (frames are just a fancy way to say message packets).</p> <p></p>"},{"location":"nodes/rc/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run rc rc\n</code></pre>"},{"location":"nodes/rc/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/rc_data (RCData from sailbot_msgs)</li> </ul>"},{"location":"nodes/sailbot_msgs/","title":"<p> Sailbot Messages </p>","text":""},{"location":"nodes/sailbot_msgs/#summary","title":"Summary","text":"<p>This package contains various custom messages types that nodes would need to send to each other! Try to add messages to the custom messages library sparingly as we would like most nodes to only publish/ listen with a message type in the base ros2 messages. This keeps our code easily compatible with other peoples' drivers so we can just drop other peoples' drivers if we ever need to.</p> <p></p>"},{"location":"nodes/sailbot_msgs/#contains-the-following-messages","title":"Contains the Following Messages","text":"<p>RCData \u00a0\u00a0\u00a0\u00a0  float32 joystick_left_x \u00a0\u00a0\u00a0\u00a0  float32 joystick_left_y \u00a0\u00a0\u00a0\u00a0  float32 joystick_right_x \u00a0\u00a0\u00a0\u00a0  float32 joystick_right_y \u00a0\u00a0\u00a0\u00a0  bool button_a \u00a0\u00a0\u00a0\u00a0  uint8 toggle_b \u00a0\u00a0\u00a0\u00a0  uint8 toggle_c \u00a0\u00a0\u00a0\u00a0  bool button_d \u00a0\u00a0\u00a0\u00a0  uint8 toggle_e \u00a0\u00a0\u00a0\u00a0  uint8 toggle_f  </p> <p>WaypointList \u00a0\u00a0\u00a0\u00a0  sensor_msgs/NavSatFix[] waypoints  </p>"},{"location":"nodes/simulation/","title":"Simulation","text":"<p>talk about building your own simulation gui and how to build sailboat-gym pip package from source talk about building your own gazebo simulation situation through the other repo</p> <p>Remember when building the simulation container from source to first install docker-buildx: <code>sudo apt install docker-buildx</code></p>"},{"location":"nodes/what_about_the_other_nodes/","title":"<p> TLDR </p>","text":"<p>For all the other nodes in the repository, don't worry about them for now. They are likely just tests or very highly under development. Either way you shouldn't worry about them on a conceptual level for now, just focus on understanding how the nodes that are documented work and developing on those unless explicitly told otherwise.</p>"},{"location":"nodes/what_about_the_other_nodes/#object-detection","title":"<p> Object Detection </p>","text":"<p>This node is supposed to take in a camera image and outputs both the relative \"yaw\" of all of the buoys and their positions as gps coordinates. In this case the \"yaw\" doesn't have to be in degrees, it just has to be proportional to the distance (number of pixels) from the center of the buoy to the center of the screen. This would mean that as this number goes to 0, we would be facing the buoy directly (which is what we want for the search event).</p>"},{"location":"nodes/what_about_the_other_nodes/#ntrip-client","title":"<p> NTRIP Client </p>","text":"<p>This node is designed to take RTCM messages from a local RTCM provider and publish them out so our gps can use them as correctional data. The node is currently fully functional; however, we haven't yet figured out how to get the gps to register the messages properly. That is what the official gps node is for.</p>"},{"location":"nodes/what_about_the_other_nodes/#official-gps","title":"<p> Official GPS </p>","text":"<p>This is a clone of the official ROS driver for our GPS series. The reason we did not use this from the start was a result of some weird choices Chris made for containerizing the entire project that didn't work with these drivers. This node works very similarly to our current GPS node; it simply listens for a GPS to plug into the device and publishes the results to a ROS topic. This ROS node, however has some other useful functionalities such as the ability to receive RTCM messages and use them as correctional data for our GPS.</p>"},{"location":"nodes/wind_sensor/","title":"<p> Wind Sensor </p>","text":""},{"location":"nodes/wind_sensor/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our wind sensor (Calypso Wind Sensor). The wind sensor gives us NMEA0183 sentences that look may look like the picture below. </p> <p></p> <p>The NMEA0183 message structure is very simple. The basics are that they always send a \"$\" when the message starts and separates different sub-messages with commas. If you would like to read more about NMEA0183, you can do so here: NMEA0183 explanation.</p> <p></p> <p>Our wind sensor sends its sub-messages in the following order: </p>"},{"location":"nodes/wind_sensor/#command-to-run-the-node","title":"Command to Run the Node","text":"<pre><code>ros2 run gps gps\n</code></pre>"},{"location":"nodes/wind_sensor/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> </ul>"},{"location":"resources/diagram_of_groundstation_telemetry/","title":"<p> Flow of Information Between Groundstation and Autopilot Node </p>","text":""},{"location":"resources/diagram_of_simulations/","title":"Diagram of How the Simulation Works and Communicates with ROS","text":""}]}