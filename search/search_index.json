{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<p> Welcome to the Virginia Tech AutoBoat Documentation!</p>","text":"<p>This document will outline how to set up the software stack on theoretically any modern computer. All of our code is contained in this Github repository, so if you want to check this out then feel free! All of the code is open source and we have a commitment to keeping all of our stuff open source for the forseable future.</p> <p></p>"},{"location":"#what-is-the-purpose-of-this-document","title":"<p> What Is the Purpose of This Document? </p>","text":"<p>The purpose of this document is to be an installation guide, overview of all of the technologies that we use, a description of how the software works, and a guide to how to use the software all in one! This is basically, in professional terms, an ICD, and the upkeep of this document is of paramount importance as this is the best and most efficient way to facilitate knowledge transfer between senior members of the club and newer members.</p> <p></p>"},{"location":"#how-do-i-get-started","title":"<p> How Do I Get Started? </p>","text":"<p>Head over to the Getting Started part of the documentation and complete the installation steps over at Installing Docker to install Docker. Then, complete the installation steps found in Setting Up the Development Container, and once you have the development container all set up, you should be ready to test everything! To get a simple simulation scenario up and running, then please visit Examples and click on the Running the Simulation. </p> <p></p>"},{"location":"#what-frameworks-and-tools-should-i-learn","title":"<p> What Frameworks and Tools Should I Learn? </p>","text":"<p>Note</p> <p>TLDR: You should absolutely be familiar with ROS2 Humble, Git, and how to use a unix shell before you start working on this codebase. You may also want to learn Docker since it is extremely widely used and may be useful to know, but this is not necessary to work on the codebase.</p> <p>Git: This should be fairly self explanatory, but git and github are extremely important to learn if you want to work on any codebase. It helps us all work on the same codebase at the same time and merge together all of our contributions to the code.</p> <p>Here are the things you should make sure you know how to do before you start working on anything:</p> <ul> <li>Understand the concepts behind and how to stage, commit, push, pull, clone</li> <li>Understand what merging two branches are and how to resolve merge conflicts (preferably in vscode)</li> <li>Understand how to reset to a previous commit by using the commands <code>git reset</code> and <code>git reset --hard</code></li> <li>Understand how to create new branches and switch between branches</li> </ul> <p></p> <p>ROS2: Our techstack utilizes ROS2 (The Robotics Operating System) at its core. Unlike its name implies, it is not an actual operating system, but rather a middleware wrapper that makes concurrency and communication between sensor, actuators, autopilots, and telemetry super easy! This is the industry standard for projects just like this one so if you ever want to do anything in robotics, then this is the framework to learn! The specific version we are using is ROS2 Humble Hawksbill or ROS2 Humble for short, and the documentation for it can be found right here: ROS2 Humble Documentation. Specifically, I would recommend heading to the Tutorials and Concepts sections as those are the most useful for beginners. In addition, there is a really good video series outlining how to get started and do stuff with ROS in addition to the concepts, which can be found here: ROS2 Tutorial Series EP1.</p> <p>Here are the things you should make sure you know how to do before you start working on anything:</p> <ul> <li>Understand what symlink installing a ROS2 package is since this is what we use instead of the traditional ROS2 build system. Another good resource can be found here: symlink install explanation</li> <li>Understand how to create ROS2 Humble packages, nodes, and entrypoints</li> <li>Understand what topics and nodes are and how nodes are able to communicate over topics</li> <li>Understand how to publish and subscribe to topics in code and through the command line</li> <li>Understand what ROS2 timers are and how to create them</li> <li>Understand basic ROS2 commands such as <code>ros2 node list</code>, <code>ros2 node info</code>, <code>ros2 topic list</code>, <code>ros2 topic info</code>, <code>ros2 topic echo</code> etc etc</li> <li>Understand how to run ROS2 nodes, what launch files are, and how to use them</li> </ul> <p></p> <p>Docker: While this isn't much of a framework, it is still an important tool and understanding how it works and the concepts behind it, will make troubleshooting if you ever run into problems a bit easier. Docker is seen pretty much everywhere in software nowadays because its a super streamlined and fast way to create custom virtual machines. It really doesn't matter which part of the software industry you would like to work in in the future, I guarantee you that you will run into docker into some point. So it's better to learn it sooner rather than later! Heres some links to documentation and videos: - Docker Overview - Docker Video Explanation 1 - Docker Video Explanation 2 </p> <p>It turns out that Docker can be used for more than just deployment though. Relatively recently, Docker introduced full support for something called Docker Development Environments (Or Docker Development Containers), which allows us to do all of our development through a Docker container right inside VSCode! Thats great because getting ROS2 and our entire project working on everyone's computers and operating systems was a nightmare to orchestrate and setup, now everyone can just install Docker and our custom development container and start developing instantly! Additionally, there are plenty of other IDEs that support integration with development containers in case you use something other than VSCode; however, VSCode is what we will focus on in this document's setup instructions.</p> <p>Here are some nice things to know about Docker before you start developing. These are nice to know but not necessary:</p> <ul> <li>Understand what containers, images, and devcontainers are</li> <li>Understand how to build an image, run an image (create a container), and how to push images to docker hub</li> <li>Understand simple commands in a Dockerfile and how to make a Dockerfile</li> </ul>"},{"location":"crontabs/","title":"<p> Crontabs </p>","text":""},{"location":"crontabs/#what-are-crontabs","title":"<p> What are Crontabs? </p>","text":"<p>Crontabs are simply processes that linux makes run periodically. If we want to run a specific command every 5 seconds, then this is the way to do it. I encourage you to check out the crontabs documentation: Crontab Man Page (Official Documentation) and Third Party Crontab Tutorial.</p>"},{"location":"crontabs/#allowing-devices-to-always-be-accessed-by-non-sudo-users-chmod777jobtxt","title":"<p> Allowing Devices to Always be Accessed by Non-Sudo Users: chmod777job.txt</p>","text":"<p>Lets say, that you would like to test the GPS on your laptop inside of the dev container. You would plug the GPS in and then linux automatically will create a file called /dev/ttyACM01 or some other name for the file that linux decides. We can control what the file is called and override the linux default, but that is outside of the scope of this part of the documentation. Critically, this file represents the GPS, and the only way to communicate and read/ write over the GPS USB port is to access this file. However, by default, you may or may not actually have access to this file as a normal user on the linux system, and sometimes, the only person who has access to this file is the sudo or admin user. So, whenever you would like to communicate with the GPS from your computer and run the GPS node, you will have to run the following command:</p> <pre><code>sudo chmod 777 /dev/**\n</code></pre> <p>This command essentially just steps in as an admin user and says that \"as an admin user, I allow all other users to do whatever they want to the GPS, read or write, I don't care. This is simplifying a little bit, but I hope it gets the point across. Normally, we would need to run this command everytime we plug in the GPS to our computers; however, there is an easier way. We can instead set it up so that this command runs every 0.5 seconds so that when you plug it in, and by the time you try to interact with the GPS, the command will very likely have already been run. This concept applies to all USB devices that you would like to plug into your computer, but I just used the GPS as a simple example.</p>"},{"location":"known_installation_issues/","title":"<p> Known Issues</p>","text":"<ul> <li>In order to get full Intellisense, you need to restart the dev container after building it. Idk how to fix this man but just go with it. The issue might be that the Docker dev environment doesn't register the .vscode folder when it first starts up which is interesting... not sure how I would go about fixing it if thats the issue.</li> </ul> <ul> <li>If the groundstation gives the following error when you boot it up:   then run the following command in a WSL terminal if you are on windows, or on a linux terminal if you are on linux: </li> </ul> <pre><code>echo \"xhost + &gt;&gt; /dev/null\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc\n</code></pre> <p>Explanation for the groundstation error:  your host operating system may not allow you to open x servers from inside of docker because \"technically its a security vulnerability\", but if you have not realized yet, security is our last priority here so we don't care. \"xhost +\" allows anyone to access your x server which lets them do whatever they want to your display, listen to keyboard inputs, etc. This command simply adds \"xhost +\" to your ~/.bashrc file, which is a series of bash commands that are run whenever your terminal opens. Then, the script runs the ~/.bashrc file to apply the changes.  \"&gt;&gt; /dev/null\" simply makes it so that the command doesn't print anything; this is not necessary at all but is nice so you don't have to see the same message everytime you open a terminal. </p> <p></p> <ul> <li>If the simulation is periodically freezing for no discernable reason then the issue is likely your system clock's synchronization, so please ensure that your system clock is synchronized to the internet. A common reason why your system clock may not be synchronized to the internet properly is if you have a dual boot, since dual boots often mess with timezone configurations.</li> </ul>"},{"location":"standards_and_definitions/","title":"<p> Standards and Definitions</p>","text":""},{"location":"standards_and_definitions/#units","title":"Units:","text":"<p>Unless stated otherwise, all variables are in SI units (meters, seconds, etc). All measurements of angles by default are in degrees from 0 to 360 degrees. </p>"},{"location":"standards_and_definitions/#definitions","title":"Definitions:","text":"<ul> <li> <p>Autopilot Mode: Autopilot mode typically refers to whether or not the autopilot is in RC control, a semi-autonomous mode like hold heading, or in a full autonomous mode. This is just a string that describes the autopilot mode for the telemetry.</p> </li> <li> <p>Full Autonomy Maneuver: The full autonomy maneuver is only really used for the sailboat in a fully autonomous mode. This describes whether the boat is currently tacking clockwise, tacking counterclockwise, or is normally sailing and navigating towards a specific heading.</p> </li> </ul>"},{"location":"standards_and_definitions/#wind-angle-vector-standards","title":"Wind Angle/ Vector Standards","text":"<p>There are several ways of measuring the wind direction and intensity that are each useful in different situations. The following are the main standards that we have chosen to go with; these exact definitions aren't standard across sailers, and you probably won't even find the words \"Global True Wind Angle\" anywhere online, but we believe that it is useful for our application and hopefully you will see why.</p> <p></p>"},{"location":"standards_and_definitions/#apparent-wind-angle","title":"Apparent Wind Angle","text":"<p>Apparent Wind Angle: The Apparent Wind is the wind measured on top of the boat. Imagine for a second that you are on a speedboat with no wind outside. When the speed boat is moving quickly, then you can feel the wind brush over your face because you are moving quickly even though there is no real wind. This is because you are moving into the air around you, which creates the sensation of wind and works in a similar way to relative motion. The following Youtube video gives a pretty good explanation of apparent wind: Apparent Wind Explanation Youtube Video. The way that we measure this angle is counter-clockwise from the centerline of the boat, which visually looks like this if the boat is facing upwards:</p> <p></p> <p>This means that if the boat is going downwind, then the wind angle is 0 degrees. If the boat is going upwind, then the wind angle is 180 degrees. If the wind is blowing towards the left side of the boat, then the wind angle is 90 degrees. This measurement of the apparent wind direction and speed is really useful for managing the exact position of our sail because the direction that our sail should be pointing is dictated mainly by the apparent wind angle. The exact behaviour of the sail will always be defined by a lookup table, so for instance, if the boat is headed downwind, then the sail should be out all of the way. If the boat is heading directly upwind, then you will want to pull the sails all the way in.  </p>"},{"location":"standards_and_definitions/#how-are-wind-vectors-calculated","title":"How Are Wind Vectors Calculated?","text":"<p>In the next section about the true wind angle, we will talk about the true wind vector and the apparent wind vector, so it may be useful to define them since we have not talked about them before. Whenever we are talking about a wind vector in any standard, the vectors always have a specific definition in relation to their corresponding wind angles and magnitudes and it is the following:</p> <p>\\(\\text{wind_vector_x} = \\text{wind_magnitude} * cos(\\text{wind_angle})\\)</p> <p>\\(\\text{wind_vector_y} = \\text{wind_magnitude} * sin(\\text{wind_angle})\\) </p> <p>This gives some pretty funky results when we start talking about the global true wind angle, but I promise it makes the math easier if you are able to follow along. Here are the x and y axes labeled for the apparent wind angle using this definition of the apparent wind vector:</p> <p></p> <p>This means that the axes that the apparent wind vector are based off of change if the heading/ direction of the boat changes. You have to keep this fact in mind when doing calculations with the apparent wind vector because this is very important.</p>"},{"location":"standards_and_definitions/#true-wind-angle","title":"True Wind Angle","text":"<p>The true wind vector is basically just the wind speed of the location as measured by a stationary sensor, and is just computed by taking the apparent wind vector and adding the local velocity vector of the boat. You must make sure that the velocity vector is measured using the same axes as the apparent wind vector. This is called the local velocity vector and is mentioned in a following section. </p> <p>\\(\\text{true_wind_angle} = \\text{apparent_wind_vector} + \\text{local_velocity_vector}\\)</p> <p>The true wind angle is also measured counter-clockwise from the centerline of the boat just like the apparent wind angle, and the true wind vector has the same base axes as the apparent wind vector. The true wind angle doesn't actually do anything on its own, but it can be used to compute the global true wind angle, which is quite useful for us in plotting courses and in visualizations.</p>"},{"location":"standards_and_definitions/#global-true-wind-angle","title":"Global True Wind Angle","text":"<p>As you may have realized, both of the two previous standards for determining the wind angle are relative to the centerline of the boat and if the direction of the boat changes, then the apparent/ true wind angles will change even if the real wind hasn't shifted. So in order to account for this, we would like to cancel out the direction the boat is facing from the true wind angle. The formula for this is quite simple: </p> <p>\\(\\text{global_true_wind_angle} = \\text{heading_counter_clockwise_from_true_east} + \\text{true_wind_angle}\\) </p> <p>I would encourage you to draw this out and convince yourself of why this fact is true and follows naturally from how we have defined everything so far.</p> <p>This calculation gives us a really good sense of where the wind is actually going regardless of our current heading/ direction and regardless of our velocity vector, which is very useful for displaying wind information to a map and figuring out where the no sail zone is.</p> <p>If you haven't realized already, this definition of the global true wind angle means that the global true wind vector has the x axis defined as true east and the y axis defined as true north. This is very different from the apparent/ true wind vectors so keep that in mind. The apparent/ true wind vector will change if the boat changes directions but the global true wind vector does not change if the boat changes directions.</p>"},{"location":"standards_and_definitions/#global-and-local-velocity","title":"Global and Local Velocity","text":"<p>Similarly to the wind angle, there is a distinction between the global velocity and the local velocity. The global velocity is simply the velocity that the GPS gives us which is measured with the x axis being true east and the y axis being true north. In order to convert this into something where the x axis is the centerline of the boat and the y axis points to the left of the boat, we need to convert to the local velocity which can be done with the following equations:</p> <p>\\(\\text{boat_speed} = \\sqrt{\\text{global_velocity_vector_y}^2 + \\text{global_velocity_vector_y}^2}\\)</p> <p>\\(\\text{global_velocity_angle} = arctan2(\\text{global_velocity_vector_y}, \\text{global_velocity_vector_x})\\)</p> <p>\\(\\text{local_velocity_angle} = \\text{global_velocity_angle} - \\text{heading_angle}\\)</p> <p>\\(\\text{local_velocity_vector_x} = \\text{boat_speed} * cos(\\text{local_velocity_angle})\\)</p> <p>\\(\\text{local_velocity_vector_y} = \\text{boat_speed} * sin(\\text{local_velocity_angle})\\)</p> <p>arctan2 is defined as simply a function that takes in the x and y components of a vector and outputs the angle that vector makes counter-clockwise from the x axis. See the following link for more details: Arctan2 Wikipedia Page</p> <p>Now, similarly to the apparent/ true wind angle, local_velocity_vector_x faces the same direction as the centerline of the boat, and local_velocity_vector_y faces to the left of the boat. This version of the velocity vector can now be added to the apparent wind vector since now both of them are being measured the same way.</p>"},{"location":"systemctl/","title":"<p> What is Systemctl?</p>","text":"<p>Systemctl is essentially a way to schedule scripts to run when a machine starts up, and this is super useful on the Jetson on the actual boat, because it allows us to start up the autopilot ROS nodes without SSH'ing into the Jetson all of the time. Before we started using systemctl, every single time we power cycled the boat, we would have to SSH into the boat and manually run <code>ros2 launch ......</code>, but now with systemctl, this command automatically runs for us everytime the boat starts up.</p>"},{"location":"systemctl/#some-useful-stuff-to-know-how-to-do-in-systemctl","title":"<p> Some Useful Stuff to Know How to Do in Systemctl</p>","text":"<p>Theres a whole bunch of things that are very useful to know how to do with systemctl processes. For example, how to create a new .service file, how to use <code>sudo systemctl enable myservice</code> (which enables the service to start on boot), how to use <code>sudo systemctl start myservice</code> (which starts the service right now), how to use <code>sudo systemctl stop myservice</code> (which stops the service from running right now), <code>sudo systemctl disable myservice</code> (which disables the service to start on boot), and <code>sudo journalctl -u myservice</code> (which shows you the print logs from a specific service).</p>"},{"location":"systemctl/#example-of-a-systemctl-file-that-we-have-used","title":"<p> Example of a Systemctl File That We Have Used</p>","text":"<p>TODO TODO TODO TODO</p>"},{"location":"systemctl/#extra-resources-to-learn-more-about-systemctl","title":"<p> Extra Resources to Learn More About Systemctl</p>","text":"<p>Making a new systemctl process: https://askubuntu.com/questions/919054/how-do-i-run-a-single-command-at-startup-using-systemd</p> <p>Using journalctl: https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs </p>"},{"location":"udev_rules/","title":"<p> What are UDev Rules and How Do We Use Them</p>","text":"<p>Udev Rules allow us to rename specific devices, so that we can very easily access them through code. Devices can usually be found in the /dev/ folder in linux and are generally accessed like devices. For example, a USB device could be found as /dev/ttyACM0, and in order to access that device, you have to provide that specific filepath. However, notice how I said \"could be found\" because this actually depends on the number of USB devices connected to your computer/ Jetson and if your computer/ Jetson is feeling devious today. The USB device could actually be found at /dev/ttyACM1, /dev/ttyACM2, etc etc. In other words, just providing the filepath is unreliable.</p> <p>Thankfully, there is another way to access devices in Linux that is related, but much easier. Essentially, every single serial device on earth is uniquely identified with a 4 digit hexademical number called a VID (vendor ID), a 4 digital hexadecimal number called a PID (product ID), and a serial number. If you know this PID, VID, and serial number, you can search through all of the devices on your computer to try to find the port that corresponds to this specific PID, VID, and serial number to find the port that the device is on. The code for this would look a little something like this:</p> <pre><code>from serial.tools import list_ports\n\ndef getPort(vid, pid) -&gt; str:\n    device_list = list_ports.comports()\n    for device in device_list:\n        if device.vid == vid and device.pid == pid:\n            return device.device\n    raise OSError('Device not found')\n</code></pre> <p>However, this is also not perfect, since we would have to repeat this code throughout every single node that connects to a USB device. Also, this won't actually help us connect to a microros agent that easily, since we need to know the name of the device in /dev/ ahead of time. To solve this and make it a little bit cleaner, we can utilize udev rules. With udev rules, we can give the udev rules a specific VID and PID and then it will automatically rename any device with that VID and PID to \"/dev/gps\" or \"/dev/wind_sensor\" or whatever you want. Here is an example of a udev rule:</p> <pre><code>ACTION==\"add\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6001\", ATTRS{serial}==\"A9001WL3\", SYMLINK+=\"rc\"\n</code></pre> <p>In this example, the USB device has a VID of 0x0403, a PID of 0x6001, and a serial number of A9001WL3. This udev rule will then automatically detect if a device with this VID, PID, and serial number connects to your computer and automatically rename the device to /dev/rc, which makes it super easy to access. </p> <p>In order to make this udev rule actually work, you need to add it to a file like /etc/udev/rules.d/99-autoboat-udev.rules or any other .rules file in the /etc/udev/rules.d folder. Once this line is added to a file in the /etc/udev/rules.d folder, it will automatically take effect. </p> <p>If you wanted to automatically add a udev rule to a file like /etc/udev/rules.d/99-autoboat-udev.rules, then you would just have to run the following command in your linux terminal:</p> <pre><code>sudo echo ACTION==\"add\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6001\", ATTRS{serial}==\"A9001WL3\", SYMLINK+=\"rc\" &gt;&gt; /etc/udev/rules.d/99-autoboat-udev.rules\n</code></pre>"},{"location":"udev_rules/#here-are-some-extra-resources","title":"<p> Here Are Some Extra Resources</p>","text":"<p>https://www.clearpathrobotics.com/assets/guides/kinetic/ros/Udev%20Rules.html</p>"},{"location":"examples/adding_a_new_ros2_node/","title":"<p> Adding a New ROS2 Node to A Package </p>","text":""},{"location":"examples/adding_a_new_ros2_node/#python-nodes","title":"Python Nodes","text":"<p>There are some really good tutorials online found here: Creating a ROS Node Tutorial, What is a ROS Topic, Creating a ROS Publisher Node, Creating a ROS Subscriber Node, and Combining a ROS Subscriber with a ROS Publisher. </p> <p></p> <p>This tutorial series is very good in general, and I would recommend looking at all the videos in the series although it is not strictly necessary.</p>"},{"location":"examples/adding_a_new_ros2_package/","title":"<p> Adding a New ROS2 Package to the Workspace </p>","text":""},{"location":"examples/adding_a_new_ros2_package/#python-packages","title":"Python Packages","text":"<p>To create a new ROS2 python package, you should first run the following command in the <code>/home/ws/src</code> folder:</p> <pre><code>ros2 pkg create &lt;Your Package Name Here&gt; --build-type ament_python --dependencies rclpy\n</code></pre> <p>Once you have created your package, you should see a new folder pop up in <code>/home/ws/src</code> that looks a little bit like this:</p> <p></p> <p>Once you add the package, ensure that you run the following commands:</p> <pre><code>cd /home/ws &amp;&amp; colcon build --symlink-install &amp;&amp; source ~/.bashrc\n</code></pre> <p>This will rebuild the environment to recognize that the new package exists. Without this, ROS2 won't be able to find your new package.</p> <p>A more comprehensive tutorial can be found here: Comprehensive tutorial on how to create a ROS2 python package</p> <p></p> <p>Once you have the ROS2 python package created, you should make your way to the next section on adding new ROS2 nodes, where we will talk about how to add new nodes to ROS2 python packages.</p>"},{"location":"examples/adding_documentation/","title":"<p> Adding Documentation </p>","text":"<p>As a team, we want our software and hardware decisions well-documented and kept in one place to ensure that new members can easily learn the big and complex system they work with, as well as quickly be plugged into development process. As such, after achieving a significant milestone, it is highly recommended to document it and contribute to this website. It is a lot easier than it sounds.</p> <p>To start, install the necessary dependencies. You do not have to do it in docker.</p> <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre> <p>mac OS Users</p> <p>We can use brew for this.</p> <pre><code>brew install mkdocs-material\n</code></pre> <p>Then, clone the github repository: <pre><code>git clone -b https://github.com/autoboat-vt/autoboat_docs\n</code></pre></p> <p>You may now make changes to the website code. To edit an existing page, simply find its .md file in <code>docs</code> and edit the text inside. To add a new page, add the file into whichever folder you want it to be (or create a new folder), type it up, and then include in <code>mkdocs.yml</code> under the nav section. The documentation supports html, markdown, and several extensions. You can read about the extensions here.</p> <p>To put your changes on the website, run: <pre><code>    mkdocs build\n    mkdocs serve\n</code></pre></p> <p>This will set the website to run locally on the <code>http://127.0.0.1:8000/</code> (localhost) IP address. To access it, just type that link in the web-browser.</p> <p>After you feel good about your changes, deploy them to the internet: <pre><code>    mkdocs gh-deploy\n</code></pre></p> <p>And don't forget to push them to the github repository!</p>"},{"location":"examples/connecting_a_usb_device_to_wsl/","title":"<p> Connecting a USB Device to WSL </p>","text":"<p>Note</p> <p>If you are on Linux or Mac, USB devices should just work in the dev containers, so you do not need any additional steps</p> <p>Sometimes, we want to test usb devices and their respective ROS nodes before we run them with the Jetson such as the GPS, RC receiver, wind sensor, Raspberry Pi Pico, VESC, etc. Most people run Windows for their personal computer, and unfortunately we have to do some slightly jank things to get everything working on Windows like it would work on the Jetson. One of which is giving USB devices to WSL so that WSL can have full access to read/ write to those USB devices. Unfortunately with how WSL works, USB devices have to belong to either WSL or Windows, so you have to manually give access over to WSL and by default, access is given to Windows.</p> <p></p> <p>Back in the day, we used to have to use a command line tool called usbipd-win, but to put it bluntly, this tool sucks. You have to interact with powershell, manually bind and attach specific devices, and figuring out which device is mounted to which bus were all just annoying. Nowadays, there exists a GUI called WSL USB GUI that simplifies all of the process of binding and attaching a USB device between Windows and WSL.</p>"},{"location":"examples/connecting_a_usb_device_to_wsl/#how-to-install-wsl-usb-gui","title":"How to Install WSL USB GUI","text":"<ul> <li> <p>Go to the following releases page for the WSL USB GUI Tool: Link to WSL USB GUI Releases Page.</p> </li> <li> <p>Click on the .msi release option for Windows:</p> </li> </ul> <p></p> <ul> <li> <p>Run the installer and click through all of the options with the defaults until you have installed WSL USB GUI</p> </li> <li> <p>Once you have finished installing the program, you should see the following show up if you search for WSL USB in the Windows search bar:</p> </li> </ul> <p></p> <ul> <li> <p>Run WSL USB GUI</p> </li> <li> <p>You should see the USB device that is plugged into your computer on here. Simply click on the device and then click \"attach\". Once the device is properly attached to WSL, you should see the device in the forwarded devices tab, and if this is true, that means that WSL can successfully see the USB device!</p> </li> </ul>"},{"location":"examples/how_we_handle_external_libraries/","title":"<p> How to Add External Libraries that We Can Edit</p>","text":"<p>Sometimes, we would like to use external pip packages, but still be able to edit the source code for them on the fly. One great example of this is the pyvesc library for the VESC node, where there are some minor differences between what the library does by default and what we want the library to do. In order to acheieve this, we will take advantage of the \"-e\" option in pip install, which allows us to install a local pip package as editable. Taking the example of the pyvesc library, here is how the source code is laid out:</p> <p></p> <p>Inside of the vesc ros2 package, we have the pyvesc library, which is very similar to the copy of the pyvesc library you can find here: Official pyvesc Library. This is where we would normally like to place our custom pip packages since it is easy to find what pip packages each ros2 package would like to use. Also, whenever you clone a git repository, it generates a folder named .git which contains all of the history of the repository. In short, we don't care about the history of the repository and in fact keeping this file makes it more annoying to use it in our codebase by automatically creating a nested repository. Nested repositories can become a nightmare to deal with, so to make all of our lives easier, just delete the .git folder. You can do so by using the rm -rf command:</p> <pre><code>rm -rf src/vesc/pyvesc/.git\n</code></pre> <p>Now that we have that working, we will need to make it so that we automatically install that package whenever someone runs <code>bash docker_dev_environment_setup.sh</code>. So, we need to add a line into the docker_dev_environment_setup.sh file like so:</p> <p></p> <p>This will automatically install the local pip package in editable mode, so if you make a change in the code of the pip package, then it will automatically reflect in any code that uses that package. If we did not have it in editable mode, then we would need to rebuild the package everytime we make a change to the source code. Now, to install the pip package, simply rerun <code>bash docker_dev_environment_setup.sh</code> and it should be ready to import in any python script inside of the dev container!</p>"},{"location":"examples/running_a_custom_simulation/","title":"<p> Running A Custom Simulation </p>","text":"<p>NOTE: Do Not Clone the Code into Your Docker Development Environment</p> <p>Make sure you clone this repository outside of the Docker development environment, because Docker gets a little fussy with building Docker images inside of a Docker Container, and I would rather not have to deal with that. If you are on Windows, this means that you should do the rest of the setup steps in WSL.</p> <p>You should only care about this installation process if you care about modifying and doing direct development on the gazebo simulation. Following these steps will allow you to modify and test a new simulation environment with modified parameters or code.  </p> <p>Before we can build a custom simulation, first we need to clone the autoboat_simulation repository.</p> <p>Open up a terminal in the folder you would like to place the code to build a new simulation in. Next type the following commands:</p> <pre><code>git clone https://github.com/autoboat-vt/autoboat_simulation \ncd autoboat_simulation\n</code></pre> <p>Now that you have all of the code on your computer, there is only 1 dependency for working with the simulation and that is docker-buildx. You can install it like this on Windows WSL and Ubuntu:</p> <pre><code>sudo apt install docker-buildx\n</code></pre> <p>mac OS Users</p> <p>If you are on mac OS, you will need to install docker-buildx using the following command:</p> <pre><code>brew install docker-buildx\n</code></pre> <p>Make sure to follow the instructions that brew gives you after running this command to make sure that docker-buildx is properly installed on your system.</p> <p>Now, all you have to do to build the simulation now is type in the following command:</p> <pre><code>sudo bash build_sim.sh\n</code></pre> <p>And thats it! Now automatically, the simulation node will instead use the new, custom simulation instead of the default. The simulation itself is quite poorly documented so if you have any questions about it and how to do certain things, please ask Chris.</p> <p>If you would like to go back to using the default simulation then all you have to do is delete the simulation docker image and repull the default simulation docker container, the simulation node will pull the default simulation image and build it.</p>"},{"location":"examples/running_individual_nodes/","title":"<p> Running Individual Nodes for Testing </p>","text":"<p>Sometimes it may be preferable to run each node in a separate terminal, so that you can get cleaner debug messages. If you would like to do this, then all of the commands to run each individual node are included in the documentation for that node.</p>"},{"location":"examples/running_simulation/","title":"<p> Running the Simulation </p>","text":"<p>To run the simulation, run the following commands in order after setting up the development container:</p> <pre><code>sudo docker pull autoboatvt/autoboat_simulation:latest\n</code></pre> <p>This command will pull the simulation docker image, which is where all of the simulation work is actually taking place! This command only needs to be run once. Once the docker image has been pulled, you shouldn't need to repull. The command may take a while, but once it is finished, run the following command:</p> <pre><code>ros2 launch /home/ws/src/launch/simulation.launch.py\n</code></pre> <p>This command will then start the simulation and autopilot. Initially, however they won't do anything because they don't have any waypoint commands, so what you will need to do is to type in the following command:  </p> <pre><code>cd /home/ws/ground_station\n</code></pre> <pre><code>./run.sh\n</code></pre> <p>Next, click on \"zoom to boat\". This should show you where the boat is currently located (likely longitude 0 and latitude 0 since this is the default location)</p> <p>Now, click somewhere on the map and then click \"Send Waypoints\". This should cause the boat on screen to start moving and indicates that you have correctly set everything up!  </p>"},{"location":"getting_started/how_to_develop_telemetry_server/","title":"<p> How to Start Developing on the Telemetry Server </p>","text":""},{"location":"getting_started/how_to_develop_telemetry_server/#installing-the-correct-version-of-python","title":"<p> Installing the Correct Version of Python </p>","text":"<p>We will assume that if you are Windows, you already have WSL installed. If you are on Windows, then development on the telemetry server will be done on WSL exclusively. We will also assume that you have python version 3.9 installed. If you do not know which python version you currently have then please run the following command:</p> <pre><code>python --version\n</code></pre> <p>If the version is incorrect or the command gives you an error because python is not found, then you will need to install the correct version of python. The easiest way to do this is probably through miniconda which is a tool that allows you to manage multiple different versions of python on the same computer very easily.</p> <p>To install miniconda, please follow the installation instructions found here: Miniconda installation instructions.</p> <p>Windows Users</p> <p>If you are on Windows, then make sure that you do this installation for linux in your WSL environment. We would like to develop the telemetry server using a unix environment because it makes everything a whole lot easier, so you need to install the correct version of python through WSL linux.</p> <p>Once your installation is done and you open up a terminal, then if you run the following command:</p> <pre><code>conda activate base\n</code></pre> <p>Once you right that, you should see the word \"(base)\" right next to your terminal which means that conda is activated and is correctly installed. In order to install the correct version of python now, please run the following command:</p> <pre><code>conda install python=3.9\n</code></pre>"},{"location":"getting_started/how_to_develop_telemetry_server/#downloading-the-codebase-for-the-telemetry-server","title":"<p> Downloading the Codebase for the Telemetry Server </p>","text":"<p>Windows Users</p> <p>Ensure that you are running the following commands in a WSL terminal in a WSL linux filesystem. If you would like to navigate to your linux filesystem from the WSL terminal then run the following command: <code>cd ~</code>, which will take you to the home directory for the linux filesystem. If you do not install this in the linux filesystem, then developing the telemetry server will be noticably laggier.</p> <p>Run the following commands:</p> <pre><code>conda activate base\ngit clone https://github.com/autoboat-vt/telemetry_server\ncd telemetry_server\npip install -r requirements.txt\n</code></pre> <p>Make Sure You Have Conda Activated When Developing</p> <p>If you do not see the word \"(base)\" next to your terminal, then conda is not activated and in order to use the correct version of python, you need to make sure you run <code>conda activate base</code> before you start running programs.</p>"},{"location":"getting_started/how_to_develop_website/","title":"<p> How to Start Developing on the Website </p>","text":""},{"location":"getting_started/installing_docker/","title":"<p> Installing Docker </p>","text":"<p>NOTE: If You Meet Difficulties Installing Docker</p> <p>Ensure that you meet Docker's system requirements listed on their documentation, if not then attempt to contact an officer or look through the Docker documentation for what to do if you do not meet the system requirements.</p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-windows","title":"<p> Installing Docker on Windows </p>","text":"<p>In order to install Docker on windows, first we must install WSL (Windows Subsystem in Linux).</p> <p>Open the command prompt with administrator privileges and type the following commands:</p> <pre><code>wsl.exe --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <p>Enter your user info to complete the installation.  </p> <p>With these steps, this will have installed WSL and Ubuntu 22.04. Docker requires Ubuntu WSL to work on Windows. For more information see the official WSL documentation: Official WSL Documentation.</p> <p>Next, we must install the Docker desktop application and connect it up to WSL.  </p> <p>The following link contains the download link for Docker desktop on Windows. Follow the download instructions, and when you are done, you should have Docker installed! Docker Desktop for Windows Install Page</p> <p>You may run into permission issues with docker, so you need to run the following commands in your WSL terminal to give your non-sudo user access to Docker.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-ubuntu-linux","title":"<p> Installing Docker on Ubuntu Linux </p>","text":"<p>Please type the following sets of commands in a terminal.</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <pre><code># Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-mac-os","title":"<p> Installing Docker on Mac OS </p>","text":"<p>Docker can be installed standalone from the website, but it is recommended to instead install via Homebrew, the unofficial official package manager for Mac OS. Homebrew is recommended over the standalone installer as it simplifies the installation process and is nice to use.</p> <p>Please install Homebrew by entering the following command into the terminal</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Now that Homebrew is installed, run the following command to install Docker Desktop</p> <pre><code>brew install --cask docker\n</code></pre> <p>To verify that the installation was successful, run the following command</p> <pre><code>docker version\n</code></pre> <p>If the installation succeeded, you should get something along the lines of the following</p> <pre><code>\u276f docker version\nClient:\n Version:           27.0.3\n API version:       1.46\n Go version:        go1.21.11\n Git commit:        7d4bcd8\n Built:             Fri Jun 28 23:59:41 2024\n OS/Arch:           darwin/arm64\n Context:           desktop-linux\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-other-operating-systems","title":"<p> Installing Docker on Other Operating Systems </p>","text":"<p>Documentation for the rest of the operating systems docker supports can be found here: Official Docker Installation Instructions for Every OS.</p>"},{"location":"getting_started/installing_microros/","title":"<p> Installing MicroROS </p>","text":"<p>To create a layer of protection between Jetson and high voltages, and extend the number of GPIO pins we have access to, we use an RP2040 microcontroller, which communicates via a serial connection. Luckily, we are able to extend our software infrastructure to it through the microros platform. It runs nodes directly on the microcontroller, and then allows them to publish and listen on topics through the USB serial connection. Due to resource-restricted nature of the microcontrollers, the code is written in C and many of the principles when writing nodes for Jetson are inapplicable.</p> <p>To install microros on your machine, run the following command. Note that the installation will take approximately 5 GB:</p> <pre><code>    cd /home/ws/src/microros\n    bash microros_setup.sh\n</code></pre> <p>Don't forget to source your ~/.bashrc file:</p> <pre><code>    source ~/.bashrc\n</code></pre> <p>Note</p> <p>Notice that you need to establish communication between Pi Pico and WSL by USB to flash it. If you are on Windows, download and install the latest release of USB support software from WSL USB GUI Releases. By default, devices are not automatically shared with WSL, so you will need to manually autoattach. For more information, check out the documentation on connecting to a USB device in WSL.</p> <p>To flash Pi Pico with a .uf2 file, plug Pico into your computer while pressing the Boot Select button (you may release it after Pi Pico is in) and run: <pre><code>    picotool_load #write/the/address/of/your/file/here\n</code></pre></p> <p>The Pi Pico cannot communicate with the computer while it is in Boot Select mode. To exit it, you can uplug it and replug it from the USB port. Alretnatively, you may run: <pre><code>    picotool_reboot -F\n</code></pre></p> <p>Then, to establish communication with Pi Pico, run the following commands:</p> <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre> <p>If you encounter problems during the installation, consult Elias.</p>"},{"location":"getting_started/installing_microros/#running-the-example-code","title":"<p> Running the Example Code </p>","text":"<p>If you want to get started with microros, a good idea would be to try to flash Pi Pico with the example file. Note that you would need to build it first: <pre><code>    cd $PICO_MICROROS_SDK_PATH\n    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n    picotool_load pico_micro_ros_example.uf2\n</code></pre></p> <p>Then, proceed to open the serial communication: <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre></p> <p>And finally, open a new terminal, and type <pre><code>    source ~/.bashrc\n    ros2 topic list\n</code></pre></p> <p>If you have done everything correctly, <code>/pico_publisher</code> would show up in the list of topics. You can watch its output by typing:</p> <pre><code>    ros2 topic echo /pico_publisher\n</code></pre>"},{"location":"getting_started/setting_up_dev_environment/","title":"<p> Before Setting Up the Dev Environment </p>","text":"<p>Make sure that you have installed Docker before doing this step. The following steps will not work if Docker is not installed on your machine. The easiest way to check whether docker is installed correctly, open a terminal and type <code>docker</code>. If an error doesn't pop up that means that you can proceed!</p> <p>mac OS Users</p> <p>In order for the simulation window to appear, you must install XQuartz as macos does not come with a x11 server. Please run the following command in your terminal:</p> <pre><code>brew install --cask xquartz\n</code></pre> <p>After installation, please follow these steps:</p> <ol> <li>Launch XQuartz. Under the XQuartz menu, select Settings.</li> <li>Go to the Security tab and ensure \"Allow connections from network clients\" is checked.</li> <li>Restart XQuartz.</li> <li>In the Terminal app or whichever terminal your using, run the following:</li> </ol> <pre><code>IP=$(/usr/sbin/ipconfig getifaddr en0)\n/opt/X11/bin/xhost + \"$IP\"\nexport DISPLAY=\"${IP}:0\"\n</code></pre> <p>You will need to run this everytime you are about to start the docker container. It is not advised to have this code in your <code>.bashrc</code> or <code>.zshrc</code> as macos is not expecting <code>$DISPLAY</code> to be set to this value and x11 apps run outside the docker container will not work.</p> <p>Also ensure that you have VSCode or some other IDE that supports Docker dev environments installed (If you are using Windows you install VSCode in WSL too). For the purposes of this documentation, we will be using VSCode but there are plenty of other IDEs that support this and they each have their own documentation for how to get this setup.</p>"},{"location":"getting_started/setting_up_dev_environment/#installing-the-development-container","title":"<p> Installing the Development Container </p>","text":"<p>Windows Users</p> <p>If you are using Windows you must do all of the following commands in the WSL filesystem</p> <ul> <li> <p>First, we need to install the development container, and to do this, please run the following command:</p> <p><code>sudo docker pull autoboatvt/autoboat_docker_dev_image</code> </p> </li> <li> <p>Next, we need to clone the main Github repository from the following URL: https://github.com/autoboat-vt/autoboat_vt. Open up a terminal and type the following command:</p> <p><code>git clone https://github.com/autoboat-vt/autoboat_vt</code></p> </li> <li> <p>Then, open up that folder in VSCode by typing the following into the same terminal:</p> <p><code>cd autoboat_vt &amp;&amp; code .</code></p> </li> <li> <p>Install the Docker Dev Containers Extension on VSCode. It should look like the following: </p> </li> </ul> <p>mac OS Users</p> <p>Before building the container, make sure that XQuartz is open and that you have run the following command in your terminal: <code>xhost localhost</code></p> <p>To test whether or not XQuartz is working correctly, run either <code>xeyes</code> or <code>xclock</code> in your terminal. Your should see a new window appear with one of the following images.</p> <p><p></p></p> <p>If you see one of these images, then XQuartz is working correctly.</p> <ul> <li>Build and enter dev container for the repo by typing in the following into the search bar at the top <code>&gt;dev containers build</code>. You should see something similar to this at the top: . Wait for a moment as the container sets itself up!</li> </ul>"},{"location":"getting_started/setting_up_dev_environment/#final-setup-after-loading-development-container","title":"<p> Final Setup after Loading Development Container </p>","text":"<p>Once you are inside your development container, go to the terminal and input the following command.</p> <pre><code>bash docker_dev_environment_setup.sh &amp;&amp; source ~/.bashrc\n</code></pre> <p>mac OS Users</p> <p>To test the connection to the Docker container, run the following commands in the terminal in the Docker container:</p> <pre><code>sudo apt-get install -y x11-apps\nxeyes\n</code></pre> <p>If you see a new window with eyes, then the connection is working correctly.</p> <p>Restart VSCode by closing it and reopening it to make sure all of the changes refresh properly.</p>"},{"location":"getting_started/setting_up_dev_environment/#connecting-back-to-the-dev-container","title":"<p> Connecting Back to The Dev Container </p>","text":"<p>If you would like to close the container and resume development on it some other time then heres how you do that. First, open a VSCode window and click on the search bar at the very top. Instead of searching like you would normally, instead type <code>&gt;open folder in container</code>. Remember to include the \"&gt;\" as thats what allows your VSCode search bar to run commands. Once you do that you should get a popup that looks something like this:</p> <p></p> <p>Click on Dev Containers: Open Folder in Container. This should navigate you to a file explorer. Using it, simply navigate to the folder that you cloned the github repo into and you should be back to your development container.</p>"},{"location":"getting_started/what_did_you_just_install/","title":"<p> What is Docker and How Does it Work? </p>","text":"<p>Docker is essentially a way to share custom (super fast) virtual machines. A Dockerfile is the instructions to create these virtual machines. These are then compiled into Docker Images which are the virtual machines stopped at whatever point the Dockerfile told it to stop at. When you run a Docker Image, you get a Docker Container. A Docker Container is the actual virtual machine that you can interact with and work with.  </p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-is-a-development-container-and-why-are-we-using-one","title":"<p> What is a Development Container and Why are We Using One? </p>","text":"<p>A Development Container is a just a Docker Container that already has all of the requirements to start developing, so you can skip setup and not worry about operating system specific software. There are a lot of software packages we rely on and some of the software that we use only works on certain versions on Ubuntu and is really hard to get your hands on with other operating systems. Docker Development Containers automate the process of installing everything by creating a Docker Image with everything installed and running that. This allows you to start developing instantely! Additionally this helps automate and streamline deployment on the Nvidia Jetson microprocessor.</p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-about-the-ground-station","title":"<p> What About the Ground Station? </p>","text":"<p>This code is supposed to be run on an operator's computer to control the boat while it is on the water by telling a cloud server what we want our boat to do. The boat (specifically the telemetry node) then listens to this cloud server, processes the data, and performs whatever action we told it to do. You can do various things like sending different parameters to the autopilot and sending waypoints. These parameters can look like the PID gains or the tacking distance or the size of the no go zone etc (in other words things that were chosen arbitrarily).</p> <p>You can also use the ground station code to control the simulation, so if you send waypoints or parameters while a simulation is running then the simulation will automatically listen to the cloud server and navigate to those waypoints/ change specific parameters.</p> <p>For more information on how the ground station sends parameters, please see the telemetry server and groundstation parts of the documentation.</p>"},{"location":"groundstation/groundstation_overview/","title":"Introduction","text":"<p>This document provides an overview of the Ground Station system, detailing its components, functionalities, and how it integrates with other systems. The Ground Station is a critical part of the overall architecture, enabling communication with the telemetry server and facilitating the management of boat operations. Link to PyQt documentation: PyQt Documentation</p>"},{"location":"groundstation/groundstation_overview/#components-overview","title":"Components Overview","text":"<p>Note about exceptions in the groundstation</p> <p>Exceptions thrown in the groundstation do not behave like exceptions thrown in regular Python code. The reason for the exception will not be printed to the console and must be handled in order for the application to continue running. If you have code that you suspect may throw an exception, please enclose it in a try/except block and handle the exception appropriately (ask Barrett if you are unsure how to handle it).</p> <p>All data that persists between runs of the Ground Station and its assets are stored in the <code>app_data</code> directory. I have tried to split up the code in the Ground Station into logical components to make it easier to understand and modify. The Ground Station is divided into the following main components:</p>"},{"location":"groundstation/groundstation_overview/#base-components","title":"base components","text":""},{"location":"groundstation/groundstation_overview/#constantspy","title":"constants.py","text":"<p>We will begin with the <code>constants.py</code> file, which defines objects that are used throughout the entire codebase. In addition, this file checks for the presence of configuration files and assets that are essential for the Ground Station's operation. The code in this file is the first to be run and is run before the actual application is registered with PyQt. If you have code that will cause the application to crash or not behave correctly when missing assets, it is best to place that code in this file. Additionally, code in this file cannot access properties of the application object created by PyQt. The icons used in the Ground Station are defined in this file, but are not able to be used until the application is registered with PyQt, which happens in the <code>main.py</code> file.</p>"},{"location":"groundstation/groundstation_overview/#thread_classespy","title":"thread_classes.py","text":"<p>The <code>thread_classes.py</code> file contains classes that are used to manage threads within the Ground Station application. I decided to places these classes in a seperate file since they don't really feel like widgets, but may be hard to find in the <code>constants.py</code> file if you didn't know they were there. These classes are essential for handling asynchronous operations and ensuring that the Ground Station can perform tasks without blocking the main application thread. I highly recommend reading the code in this file to understand how threads are managed and how they interact with the rest of the application. Online resources on threads and how they work in PyQt may also be helpful if you are trying to work with the code in this file.</p>"},{"location":"groundstation/groundstation_overview/#mainpy","title":"main.py","text":"<p>This file is the main entry point for the Ground Station application. The code in this file is pretty self-explanatory and will probably only need to be modified if you are adding entirely new functionality to the Ground Station. If you need to know the specifics of what happens in this file, I recommend reading the code itself.</p>"},{"location":"groundstation/groundstation_overview/#syntax_highlighters","title":"syntax_highlighters","text":""},{"location":"groundstation/groundstation_overview/#base_highlighterpy","title":"base_highlighter.py","text":"<p>The <code>base_highlighter.py</code> file contains the base class for syntax highlighters used in the Ground Station. I wanted to take the QSyntaxHighlighter class and write some methods that would make it easier to write syntax highlighters for whatever I needed. The methods in this class are meant to guide the implementation of syntax highlighters so that time is not wasted trying to understand each individual method in the QSyntaxHighlighter class. The methods in this class are not meant to be used directly, but rather to be overridden in subclasses that implement specific syntax highlighting functionality. If you are writing a syntax highlighter for the Ground Station, you should start by subclassing this class and implementing the methods that are relevant to your use case.</p>"},{"location":"groundstation/groundstation_overview/#jsonpy","title":"json.py","text":"<p>The <code>json.py</code> file contains a syntax highlighter specifically designed for JSON files. It extends the base highlighter class and implements the necessary methods to provide syntax highlighting for JSON syntax. This highlighter is used to enhance the readability of JSON files within the Ground Station, making it easier to work with configuration files and other JSON data.</p>"},{"location":"groundstation/groundstation_overview/#consolepy","title":"console.py","text":"<p>The <code>console.py</code> file contains a syntax highlighter for the console output within the Ground Station. This highlighter is designed to improve the readability of console messages, making it easier to identify important information, warnings, and errors. It uses the base highlighter class to implement specific highlighting rules for console output, ensuring that messages are displayed in a clear and organized manner.</p>"},{"location":"groundstation/groundstation_overview/#widgets","title":"widgets","text":""},{"location":"groundstation/groundstation_overview/#groundstationpy","title":"groundstation.py","text":"<p>This is the magnum opus of the Ground Station application. It was the first widget I wrote for the Ground Station and is first widget that you see when you open the application. It serves as the main interface for interacting with the Ground Station and allows users to add and remove waypoints and buoys, view telemetry data, and shows popups that that are used to modify the state of the Ground Station. This file also uses some of the classes in the <code>thread_classes.py</code> file to manage asynchronous operations, such as fetching telemetry data and updating the interface without blocking the main thread. If you are looking to understand how the Ground Station works, this is a great place to start.</p>"},{"location":"groundstation/groundstation_overview/#popup_editpy","title":"popup_edit.py","text":"<p>This widget is used to create 'windows' that make it easier to modify text in the Ground Station. It takes highligther (such as one of the syntax highlighters defined in the <code>syntax_highlighters</code> directory), some initial text, a tab width, and font size as arguments and uses a QSignal to return the modified text when the user clicks the \"Save\" button or closes the window. This widget is used in the Ground Station to edit buoy data, some data types in the autopilot parameter editor, and the telemetry data 'limits' that are used to determine when a warning or error should be displayed.</p>"},{"location":"groundstation/groundstation_overview/#console_outputpy","title":"console_output.py","text":"<p>This widget is used to display the console output of the Ground Station. It uses a QPlainTextEdit to display the output and the <code>console.py</code> syntax highlighter to provide syntax highlighting for the output. It also contains the code that makes it possible to have the console output displayed in the terminal and in the Ground Station at the same time. This is done by using a QThread and some redirection of the standard output streams to capture the console output and display it in the widget.</p>"},{"location":"groundstation/groundstation_overview/#map_widget","title":"map_widget","text":"<p>This directory contains the code that is used to make displaying the waypoints and buoys on a interactive map possible. It contains a Go server that is used to manage the transfer of waypoints and buoys between the Python code and the JavaScript code running in the HTML file in this directory. The Go server exposes a <code>get</code> and <code>set</code> endpoint that modifies an array containing the latitude and longitude of the waypoints and buoys which takes the form:</p> <pre><code>[\n    [1.0, 1.0],\n    [2.0, 2.0],\n    [3.0, 3.0],\n    ...\n]\n</code></pre> <p>Where latitude is the first element of each array and longitude is the second element. The JavaScript code in this directory uses the Leaflet library to display the waypoints and buoys on a map.</p>"},{"location":"groundstation/groundstation_overview/#camera_widget","title":"camera_widget","text":"<p>This widget is used to display the camera feed from the boat. It uses a QThread from the <code>thread_classes.py</code> file to fetch the camera feed and then runs some JavaScript code to display the feed in a HTML file. We are using an HTML file to display the camera feed because of its abibility to natively show base64 encoded images, saving us the trouble of having to do the decoding ourselves. The widget has buttons that allow you to start and stop the camera feed in order to save bandwidth and processing power when the camera feed is not needed.</p>"},{"location":"groundstation/groundstation_overview/#autopilot_param_editor","title":"autopilot_param_editor","text":"<p>This widget is used to manage the autopilot parameters of the boat. It provides a scrollable table that features a search bar to filter the parameters by name. The widget uses a json file located in the <code>app_data/autopilot_params/params_default.jsonc</code> file to manage the default configuration for each of the parameters. This json file takes the form:</p> <pre><code>{\n    \"param_name\": {\n        \"type\": \"example_type\",\n        \"default\": \"example_default_value\",\n        \"description\": \"This is a description of the parameter.\",\n    },\n    ...\n}\n</code></pre> <p>Where <code>param_name</code> is the name of the parameter, <code>type</code> is the type of the parameter, <code>default</code> is the default value of the parameter, and <code>description</code> is a description of the parameter. The parameter type must be one of the built-in types (i.e <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>list</code>, <code>dict</code>, or <code>set</code>) in order for the parameter to be usable in the widget. Additional types should be defined in the <code>constants.py</code> file and properly handled in the code for the widget.</p> <p>When the application is started, it copies the contents of the <code>params_default.jsonc</code> file to a new file in the <code>autopilot_param_editor</code> directory called <code>params_temp.json</code> (all comments are stripped). This file is used to store the current values of the parameters and is updated whenever the user modifies a parameter in the widget. When the user clicks the \"Save\" button, a dialog allows the user to save the current parameters to a new file. If no file is selected, the parameters are not saved and the application continues on.</p> <p>In addition, the widget allows you to send, recieve, and reset each parameter to the value defined in the <code>app_data/autopilot_params/params_default.jsonc</code> file.</p>"},{"location":"hardware/squircuit/","title":"<p> Squircuit </p>","text":"<p>Squircuit is the name of our PCB in development. It is intended to decrease the amount of wiring we have to do. The squircuit contains three buck converters for three different power lines (5V, 9V, and 15~20V), two slots for motor controllers, a relay driver, fuses, and the outputs. The images below show the layout of the entire crcuit as well as the pinout of specifically Pi Pico.</p> <p></p> <p></p>"},{"location":"hardware/wiring_color_scheme/","title":"<p> Wiring Color Schemes </p>","text":"<p>In order to efficiently wire our numerous peripheral devices, we decided to use a coloring standard that will simplify identifying what wire belongs to what interface.</p> Interface Pin Color General Power \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 GND \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 I2C SCL \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SDA \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 UART RX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 TX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SPI SCLK \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MISO \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MOSI \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 CS \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0"},{"location":"misc/potential_security_risks/","title":"Heres where I put potential security risks which don't matter at all right now but may matter in the future.","text":"<p>In the future though if we ever want to open source this and release it as a tool for others to use or a product, this would be where to start. - dev container uses docker.sock which needs to have permissions granted to it. So I just do it through ~/.bashrc - <code>autoboat_user ALL=(ALL) NOPASSWD: chmod</code> is appended to /etc/sudoers when building the image. This is not the safest lol</p> <p>Please contact chris (animated__ through discord) if you want to change these things but don't know if we are at a stage where you should/ how to do it</p>"},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/","title":"<p> AutoBoat Messages </p>","text":""},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/#summary","title":"Summary","text":"<p>This package contains various custom messages types that nodes would need to send to each other! Try to add messages to the custom messages library sparingly as we would like most nodes to only publish/ listen with a message type in the base ros2 messages. Here is a list of all of the standard messages that I would recommend using. This keeps our code easily compatible with other peoples' drivers so we can just drop in other peoples' drivers if we ever need to.</p> <p></p>"},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/#contains-the-following-messages","title":"Contains the Following Messages","text":"<p>RCData: A standardized way to send RC Data based on the Radiomaster TX12 buttons. Includes both joysticks and all switches/ buttons</p> <p>WaypointList: A list of NavSatFix objects (https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/NavSatFix.html) that represents a list of waypoints. These are passed around and then interpretted by the autopilot to figure out how it should move to get to those waypoints.</p> <p>VESCControlData: Contains all of the data that you need to send in order to command the vesc</p> <p>VESCTelemetryData: Telemetry data from the VESC that gives us feedback about how fast the motor is spinning, how much voltage/ current is being used, etc</p> <p>ObjectDetectionResult: Contains a confidence value and an xy position for the object that the computer vision model found</p> <p>ObjectDetectionResultsList: A list of ObjectDetectionResults</p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/","title":"<p> Autopilot Nodes </p>","text":""},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#summary","title":"Summary","text":"<p>These nodes are responsible for listening to data about the current state of the boat and a set of waypoints and publishing the desired motor behaviour based on our autopilot software. These nodes run completely asynchronously on an internal timer, which means that a few times every seconds it runs a non-blocking script to calculate what the desired motor behaviours should be and publishes them when its done. This node does not actually have code to communicate with motors directly, but instead lets the microcontroller and vesc node figure out the specifics of how to communicate with the motor controllers.</p> <p>Additionally, these nodes publish data that is useful for telemetry and debugging such as the the current maneuver it is attempting to perform and what its desired heading is currently.</p> <p>An important thing to note is that these nodes also control basic RC override, which is why they need to listen into the raw RC data. There are several different types of RC override listed below: </p> <p>Above, you can find all of the different operating modes of the sailboat autopilot, which all depend on the current values of the toggle on the remote controller. The \"toggle\" or 3 way switches on the remote control are the main way that we select which autopilot mode we are in. Autopilot modes describe whether the autopilot is in RC mode, waypoint mission mode, hold current heading mode, etc etc. This encompasses all manner of autonomous and semiautonomous modes, which are useful to easily change from the ground. When the 3 way switch is all the way down (or in other words farthest away from you), then the switch is considered to be in \"state 0\". If the switch is in the middle, it is considered to be in \"state 1\", and if the switch is fully up (or fully towards you) then the switch is considered to be in \"state 2\".</p> <p>The following is an explanation of what all of the current autopilot modes do. In the future, we will likely want to add more of these modes to have different behaviours. </p> <p>Disabled (sailboat + motorboat): The rudder/sail/propeller will not move and the boat is basically limp. This functions pretty much as a kill switch.</p> <p>Full_RC (sailboat + motorboat): The rudder/sail or the rudder/propeller are both controlled by the remote controller.</p> <p>Waypoint_Mission (sailboat + motorboat): The boat will attempt to follow a set of waypoints that are given to it by the groundstation.</p> <p>Hold_Heading (sailboat + motorboat): The boat will attempt to keep the heading that it entered the Hold_Heading mode in with its rudder. For example, if you put the boat in Hold_Heading mode while the boat has a heading of 30 degrees, then the boat will attempt to keep its heading at 30 degrees. The sail/propeller is still controlled by the remote controller.</p> <p>Hold_Best_Sail (sailboat): The boat will attempt to hold the best sail angle. Generally, for every state the boat is in, there is an optimal angle to hold the sail at. For more information, check out the Sailboat Autopilot Documentation. The rudder is still controlled by the remote controller.</p> <p>Hold_Heading_And_Best_Sail (sailboat): the boat will attempt to do Hold_Heading and Hold_Best_Sail at the same time.</p> <p></p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#the-autopilot-parameters-system","title":"The Autopilot Parameters System","text":"<p>In order for us to be able to control and tune parameters for the autopilot from the groundstation, these nodes also listen for autopilot_parameters. These are jsons (serialized as strings) which detail all of the new parameters and what their values should be. These values are sent from the groundstation to the telemetry server, then to the telemetry node and then finally to the autopilot (a diagram of how exactly this is done can be found in the system diagrams). An example of these parameters is shown below:  </p> <p>Not all of the parameters need to be included in the json. If only some of the parameters are included, then only those parameters will get changed in the autopilot. The default parameters can be found in the config folder and whenever a parameter is not specified by the groundstation, it will default to the parameter values found in the config folder. Also, the default parameter files in the config folder represent all of the parameters that the autopilot can accept, so if you are ever curious about which parameters you can change in the autopilot, then please check out the default parameters files.</p> <p></p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#choosing-the-correct-rudder-angle","title":"Choosing the Correct Rudder Angle","text":"<p>One of the tasks that the autopilot aims to do is to choose the correct rudder angle, so that our boats can follow a certain heading. A lot of the time, this isn't so simple because of how non-linear this problem ends up being. So, we choose to use a PID controller to be flexible enough to handle non-linearity, while still having the option to revert back to a simple proportional controller. </p> <p></p> <p>If you are lost on any of the controls terminology, then I would recommend that you look at some of the following resources: Proportional Controller Tutorial and PID Controller Introduction. These resources are just a start, and if you would like to work on the autopilot, I would highly recommend you look more into basic control theory and become intimately familiar with how these work. </p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#what-is-the-should_propeller_motor_be_powered-topic","title":"What is the should_propeller_motor_be_powered topic?","text":"<p>This topic basically turns off a contactor that denies power to the propeller motor. This is implemented for safety, since we would like to know whether the high voltage system and the propeller motor is live whenever we want to swap out propellers or move the boat. </p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#why-does-the-autopilot-node-control-whether-the-contactor-should-be-closed-cant-the-raspberry-pi-pico-directly-receive-rc-data-and-then-control-the-contactor","title":"Why does the Autopilot Node Control Whether the Contactor Should be Closed. Can't the Raspberry Pi Pico Directly Receive RC Data and then Control the Contactor?","text":"<p>We would like the contactor to be controlled by RC command primarily, but we would also like to support the idea that in the future, we may want the autopilot to complete a route, and then unpower itself so that we can take it out of the water safely without having to manually depower it via RC. Another reason is that the raspberry pi pico code is a little harder to change, and if we wanted to change which toggle the contactor switch/ kill switch would be tied to (or really any of the RC buttons), we could theoretically do that through autopilot parameters and the groundstation. This is ideal, but also not implemented yet. Also, if we must make the decision that the raspberry pi pico must listen to the RC data topic at all, that means that there will be a lot of serial port traffic over the usb port to the raspberry pi pico, since the jetson needs to send the entirety of the RC data struct many many times per second. This may eat up CPU time on both the Jetson and the Pico and make them both less responsive (sort of). The CPU time is kind of a pedantic reason and really we would want to benchmark and see whether this actually makes any meaningful difference.</p> <p>TLDR: this is kinda just how I chose to do it since all of the other RC functions are described in the autopilot and all of the reasons above are retroactive cope</p> <p></p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot motorboat_autopilot\n</code></pre>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#choosing-the-best-sail-angle","title":"Choosing the Best Sail Angle","text":"<p>As it turns out, for any apparent wind angle, there is an optimal sail angle that you should turn the sail to. This is perhaps the only simple thing about the autopilot. There are plenty of diagrams such as the one below that demonstrate what those optimal sail angles are: </p> <p></p> <p>As long as the sail angle follows this pattern for the sail angle, then the boat will be moving the fastest in that direction. To accomplish this, we use a lookup table that linearly interpolates between the optimal sail angles given in the sail lookup table (which is described in the autopilot parameters):</p> <p> </p> <p>The code works by taking the two closest wind angles and their corresponding closest sail angles, then we construct a line out of that and figure out where we fall along that line. This is called linear interpolation. </p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-do-we-sail-upwind","title":"How Do We Sail Upwind?","text":"<p>You may be wondering, how is the boat able to sail slightly upwind in the sailing diagram. Well, this is a neat quirk of sailing that is the entire reason why sailing is even possible in the first place. If we are able to hold an angle right outside of this \"no sail zone\", then we are able to gain some ground going upwind, and if we can go in a zig zag motion upwind, then we are able to move upwind and not make any net progress to the side. Here is a video that visually explains how it works: Sailing Tutorial Video. Skip to 23:00 if you want the tacking explanation, but the entire video is pretty good, so I would recommend watching all of it.</p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-do-we-determine-when-to-tack","title":"How Do We Determine When to Tack?","text":"<p>A very simple way to tack is to check whether the waypoint is in the no sail zone. If the waypoint is in the no sail zone, then keep a close hauled position (it doesn't matter too much whether you keep close hauled to the left of the waypoint or to the right of the waypoint). The boat will then keep that close hauled position until the waypoint goes out of the no sail zone, and then the boat will tack towards the waypoint and successfully capture the waypoint. This method will ensure that the boat will have to tack exactly once to get to its destination. A visual represntation of what this looks like is shown below:</p> <p></p> <p>To determine when to tack, we have to introduce a concept called decision zones. This concept doesn't really exist anywhere online because we invented it for autonomous tacking. Essentially if we create another zone inside of the nogo zone called the decision zone and pay attention to the line between the boat and the next waypoint, then whenever the line between the boat and the next waypoint is in \"zone 1\" then we should hold a tack on the left side of the wind. Whenever the line between the boat and the next waypoint is in \"zone 3\" then we should hold a tack on the right side of the wind. Finally, if the line is in zone 2, you should continue holding the tack that you were previously holding. A visual representation of the decision zone and what a path when using decision zone tacking can both be found below:</p> <p></p> <p></p> <p>So then that begs the question, how large should the decision zone be. Well a couple of years ago, we had some team members derive the theoretically optimal decision zone size if you want to go a specific distance before tacking. This formula can be found below:</p> <p></p> <p>This formula is not perfect and can often be very wrong due to factors like noisy sensor data, the wind shifting, the boat drifting due to water currents, etc; however, it provides a good baseline for us to use in our algorithm.</p> <p>Using the decision zone tacking strategy and constantely updating the size of our decision zone, we can efficiently sail upwind!</p> <p></p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot sailboat_autopilot\n</code></pre>"},{"location":"ros2_packages/autopilot_package/telemetry/","title":"<p> Telemetry </p>","text":""},{"location":"ros2_packages/autopilot_package/telemetry/#summary","title":"Summary","text":"<p>This node is responsible for listening to various topics and sending the data to the telemetry server so that we, with the groundstation, can view the data. Additionally, this node is also responsible for listening to autopilot parameters and waypoints stored in the telemetry server and sending them to the autopilot node. This allows us to change parameters of the autopilot and change the waypoints the boat needs to follow from the shore.  </p> <p>The telemetry node listens to data about the boats current state such as the position, velocity, heading, apparent wind vector. It also listens in on data that lets us know what the autopilot is currently thinking such as the current sail/ rudder angle, the heading it is trying to sail towards, a list of all of the waypoints that it is trying to follow, an index that represents what waypoint the autopilot is currently on, the name of the mode the autopilot is currently on (whether it is in RC mode, full autonomy mode, or some semi-autonomous mode), and the maneuver the boat might be trying to perform if it is in full autonomous mode (like tacking/ jibing).</p> <p>The telemetry node will coalesce all of this information into a single json, and send that json over to the telemetry server. The telemetry server will then pass that data along verbatim to the groundstation, so the groundstation can properly interpret that data.</p> <p>The reason that this is a separate node from the autopilot nodes is that we would ideally like to have the option to run the autopilot without a WiFi connection, so if the telemetry code is in its own node, then we can just choose to not launch the telemetry node, and it should work perfectly!</p> <p>If you would like more information on the telemetry node and what information it receives and how it communicates with the telemetry server/ groundstation, please see the ros system diagrams and the system diagram specifically for the groundstation/ telemetry.</p> <p>If you would like to learn more about the specific https routes that are available in the telemetry server and what their role is, then please refer to the telemetry server documentation</p> <p></p>"},{"location":"ros2_packages/autopilot_package/telemetry/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot telemetry\n</code></pre>"},{"location":"ros2_packages/microros_package/microros/","title":"<p> Microros </p>","text":""},{"location":"ros2_packages/microros_package/microros/#summary","title":"Summary","text":"<p>This is the main package for MicroROS development. Due to the nature of microcontrollers, only one package can be run on a Pi Pico. However, there are few limitations as to how many nodes can be run. Since the RP2040 chip installed on Pi Pico has two cores, we can even run some of the nodes in parallel, taking full advantage of multithreading. All of the nodes will be documented in this file. To get started with microros development, check out Installing MicroROS in misc.</p> <p>All the nodes, their common resources, execution order, and scheduling are managed in the main.c file in the src folder. If you want to add a .c file with a node, as well as in add_executable section in CMakeLists.txt. Depends on if you include new libraries you might want to add them in CMakeLists.txt too. Important libraries and ports are located in common_microros_libs.h, which is preferable to include in each file within src folder. If you need to define ports or pins, UART for example, you do it there. To build an already existing project, execute the following commands inside <code>/microros/</code> (not <code>/microros/src/</code>): <pre><code>    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n</code></pre> From here on, after making changes to the code, you can build it simply by running <code>make</code>. Next steps, such as opening communication with ROS or flashing Pico are detailed in Installing MicroROS. </p> <p></p>"},{"location":"ros2_packages/microros_package/microros/#how-to-run","title":"How to Run","text":"<pre><code>sudo chmod 777 /dev/** &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/pico -b 115200\n</code></pre>"},{"location":"ros2_packages/object_detection_package/object_detection/","title":"<p> Object Detection </p>","text":""},{"location":"ros2_packages/object_detection_package/object_detection/#summary","title":"Summary","text":"<p>This node is responsible for detecting buoys and baoats while in the water, which includes calculating the angle and distance. To detect the buoys, our system uses a computer vision model based on Ultralytics Yolo11. We use the Ultralytics  results object to retrieve any information about object detections. We also use ROS2 to publish the angle to the buoy, the depth distance to the buoy as well as a list of detection results that involve the cnofidence value, relative x-position, and relative y-position of the detrected bounding boxes.</p> <p></p> <p>To find the code for this node, please look at the follow huggingface repository: (Object Detection Hugging Face Repository)[https://huggingface.co/datasets/Aanimated/autoboat_vt_object_detection/tree/main]. The reason that we use a huggingface repository for the object detection code is because we have a lot of large images and models in the repository, which github does not like. Huggingface repositories work a lot like github repositories; however, they are able to handle much larger models and datasets, since they are made for models and datasets. </p>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/","title":"<p> TLDR </p>","text":"<p>For all the other nodes in the repository, don't worry about them for now. They are likely just tests or very highly under development. Either way you shouldn't worry about them on a conceptual level for now, just focus on understanding how the nodes that are documented work and developing on those unless explicitly told otherwise.</p>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/#ntrip-client","title":"<p> NTRIP Client </p>","text":"<p>This node is designed to take RTCM messages from a local RTCM provider and publish them out so our gps can use them as correctional data. The node is currently fully functional; however, we haven't yet figured out how to get the gps to register the messages properly. That is what the official gps node is for.</p>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/#official-gps","title":"<p> Official GPS </p>","text":"<p>This is a clone of the official ROS driver for our GPS series. The reason we did not use this from the start was a result of some weird choices Chris made for containerizing the entire project that didn't work with these drivers. This node works very similarly to our current GPS node; it simply listens for a GPS to plug into the device and publishes the results to a ROS topic. This ROS node, however has some other useful functionalities such as the ability to receive RTCM messages and use them as correctional data for our GPS.</p>"},{"location":"ros2_packages/sensors_package/gps/","title":"<p> GPS </p>","text":""},{"location":"ros2_packages/sensors_package/gps/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our GPS (Sparkfun NEO-M8P-2) and using various filtering techniques to clean the data and make it less noisy. Our GPS gives us both position and velocity data by tracking satellites in the sky, so performance may vary depending on how cloudy it is. </p> <p>We use the sparkfun-ublox-gps pip package to communicate with the gps, although in the future, we could look into the pyubx2 library as that seems to have more features. </p> <p>In the future we may also want to look into RTK (real time kinematics) to increase our GPS accuracy, but even without that, our GPS module is really precise with 0.5 meter accuracy! RTK would be nice though because it allows us to apply less aggressive filtering techniques and still get good results.</p> <p></p>"},{"location":"ros2_packages/sensors_package/gps/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run sensors gps\n</code></pre>"},{"location":"ros2_packages/sensors_package/rc/","title":"<p> RC (Remote Controller) </p>","text":""},{"location":"ros2_packages/sensors_package/rc/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our RC (remote controller). The remote controller that we use is the Radiomaster TX12 and the receiver that we use is the Radiomaster ER6. The communication protocol that we use is called CRSF with ExpressLRS, and we use the crsf_parser pip package to help us parse the crsf frames (frames are just a fancy way to say message packets).</p> <p>Here are some resources to understand the CRSF protocol: </p> <p>Useful reddit thread</p> <p>Source Code for an Arduino CRSF Parser</p> <p>:p Yeah thats it, there aren't many good resources unfortunately.</p> <p>If you would like to have some more resources on the receiver and transmitter they are available here:</p> <p>ER6 Receiver User Manual</p> <p>TX12 Quickstart Guide</p> <p>TX12 Transmitter User Manual</p> <p>Misc Radiomaster Documentation Collection (not necessary unless we want to buy another radiomaster product)</p> <p></p>"},{"location":"ros2_packages/sensors_package/rc/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run sensors rc\n</code></pre>"},{"location":"ros2_packages/sensors_package/wind_sensor/","title":"<p> Wind Sensor </p>","text":""},{"location":"ros2_packages/sensors_package/wind_sensor/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our wind sensor (Calypso Wind Sensor). The wind sensor gives us NMEA0183 sentences that look may look like the picture below. </p> <p></p> <p>The NMEA0183 message structure is very simple. The basics are that they always send a \"$\" when the message starts and separates different sub-messages with commas. If you would like to read more about NMEA0183, you can do so here: NMEA0183 explanation.</p> <p></p> <p>Our wind sensor device sends its sub-messages in the following order: </p> <p></p>"},{"location":"ros2_packages/sensors_package/wind_sensor/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run wind_sensor wind_sensor\n</code></pre>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/","title":"<p> Sailboat Simulation </p>","text":""},{"location":"ros2_packages/simulation_package/sailboat_simulation/#summary","title":"Summary","text":"<p>The simulation node simulates all of the real world interactions that the boat will undergo without having to put the boat on the water. The simulation essentially takes the place of all of the sensor nodes and the microros nodes and should publish/ subscribe to the same things as those nodes. For more information on how the simulation interacts with everything else, please look at the system diagram for ros nodes for the simulation.</p>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/#how-it-works","title":"How it Works","text":"<p>The simulation node is basically a wrapper around the sailboat_gym repository, which can be found here: Sailboat Gym Github Repository. This repository basically has a docker container that all of the actual simulations happen in because there is a gazebo simulator for the sailboat inside of the docker container. The sailboat_gym repository then communicates with the docker container and controls the sailboat that exists inside of the docker container. The docker container is based off of the following repository: USV Sim LSA Github Repository, which is the gazebo environment that is run inside of the docker container. We can actually edit the docker container ourselves and have our own custom versions of the simulation, which is what I have set up the following repository for: Our Sailboat Simulation. In this github repository, you can edit the code for the simulation and then rebuild the docker image to be used whenever you use the simulation node. For more information, please look at the running a custom simulation documentation. You should also check out the system diagram for the simulation stack as it provides a visual explanation for how all of these pieces of code interact with each other.</p> <p>The simulation node simply imports the sailboat_gym repository and then ties specific actions to publishers and subscribers. For instance, if you publish a sail and rudder command, then the simulation node will pass that onto the sailboat_gym repository which will correspondingly control the boat in the simulation.</p> <p></p>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run simulation simulation\n</code></pre>"},{"location":"ros2_packages/vesc_package/vesc/","title":"<p> VESC (Vedder Electric Speed Controller) </p>","text":""},{"location":"ros2_packages/vesc_package/vesc/#what-is-a-vesc","title":"What is a VESC?","text":"<p>A VESC is one type of electric speed controller, which regulate the speed and power that goes into our big propeller motor. VESCs are really only used for our motorboats, since motor controllers like these are usually overkill for the smaller motors in our sailboat. The big advantage of using a VESC controller instead of any random ESC controller is that the VESC firmware (which is the main thing that characterizes a VESC controller) provides a standardized way to send and receive complex control messages and telemetry data. It also has a lot of functionality built into the firware to allow for you to change voltage limits, shut-off voltages, PID constant values, encoder configurations, etc etc all from your computer or your phone via bluetooth. You can even change these things on the fly through custom software you can write. This is great! this means that we can write software to communicate with one ESC, and we guaranteed that it will work on another ESC that is running the VESC firmware. We are also assured that we can get a plethora of telemetry data back from a VESC on how much voltage our battery has, how much voltage/ current/ power is going to our motor, how much RPM our motor has, the temperature of our motor, etc.</p> <p>If it is not obvious yet, VESC is great and we would like to mainly buy VESC compatible ESCs whenever we would like to spec an ESC for a certain motor and desired system power. If you would like to read more about the wonders of VESC, you can do so here: VESC Tutorial and Other VESC Tutorial. If you would like to download VESC Tool which is the software that you can download on your computer or phone to configure and control the VESC without the VESC Node, you can do so here: VESC Tool Download.</p>"},{"location":"ros2_packages/vesc_package/vesc/#how-does-the-vesc-node-work","title":"How Does the VESC Node Work","text":"<p>The VESC node works by using an open source library called pyvesc, which is a python implementation that allows us to send and receive messages from the VESC over the USB serial port. The original pyvesc github can be found here: pyvesc github, and the documentation can be found here: pyvesc documentation</p> <p>For this project, we may want to modify the pyvesc library slightly to better suit our needs, so we have a modified version of the pyvesc library set up inside of the vesc package folder. Check out the documentation on custom libraries to learn more about how we use custom libraries in our ROS workspace.</p> <p>The VESC Node simply takes in ROS2 messages for the VESC control struct, and sends that information to the VESC controller whenever it receives the data from the autopilot. Meanwhile, the node also reads telemetry data from the VESC at a set interval and publishes it back out so that any node can listen in on the RPM, power, etc of the motor.</p> <p>I will go into a little bit of depth in how the VESC control struct works since it isn't completely obvious how it works. The VESC control struct has the following entries:</p> <p></p> <p>string control_type_for_vesc</p> <p>float32 desired_vesc_current</p> <p>float32 desired_vesc_rpm</p> <p>float32 desired_vesc_duty_cycle</p> <p></p> <p>The \"control_type_for_vesc\" can take on the following values: \"rpm\", \"duty_cycle\", or \"current\". Each of these are different ways to control the propeller motor by telling the VESC what you want the desired RPM to be, telling the VESC what you want the duty cycle (basically voltage to the motor) to be, or telling the VESC what you want the current to the motor to be. The VESC's job is to use the control type and your desired values, and get as close to that as possible; for the purposes of this project, how it does that is basically magic. </p> <p>If control_type_for_vesc is \"rpm\", then the only other entry in the struct that matters is the \"desired_vesc_rpm\" entry which tells the motor what the desired RPM is. All other entries are basically ignored. The same happens with the rest of the control types. So to summarize, only 2 of the entries in the struct ever matter at one time, and it depends on the value of the \"control_type_for_vesc\" string.</p> <p></p>"},{"location":"ros2_packages/vesc_package/vesc/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run vesc vesc\n</code></pre>"},{"location":"system_diagrams/diagram_of_groundstation_telemetry/","title":"<p> Flow of Information Between Groundstation and Autopilot Node </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Flow of Telemetry Information Between Groundstation and Autopilot Node Source File Download</p>"},{"location":"system_diagrams/diagram_of_ros_nodes/","title":"<p> How Nodes Interact on the Sailboat Simulation </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat Simulation Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-sailboat-on-real-hardware","title":"<p> How Nodes Interact on the Sailboat on Real Hardware</p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat on Real Hardware Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-motorboat-on-real-hardware","title":"<p> How Nodes Interact on the Motorboat on Real Hardware </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Motorboat on Real Hardware Node Diagram Source File Download</p>"},{"location":"system_diagrams/diagram_of_simulations/","title":"<p> How Each of the Different Codebases Contributing to the Simulation Interact </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Simulation Diagram Source File Download</p>"},{"location":"telemetry_server/telemetry_server_api_routes/","title":"<p> Telemetry Server API Routes </p>","text":""},{"location":"telemetry_server/telemetry_server_api_routes/#how-to-access-and-test-these-routes","title":"<p> How to Access and Test These Routes </p>","text":"<p>If you would like to manually test some of these routes to see if they are working without having to make any extra scripts, then you should use an API tester like Postman. This will allow you to specify an IP, port, route, and json payload to send the route (for the \"set\" routes).</p> <p></p> <p>You can also test all of the \"get\" routes by typing something like the following in a web browser, but replace \"current_ip_address\" with the current telemetry server IP address:</p> <pre><code>&lt;current_ip_address&gt;:5000/boat_status/get\n</code></pre> <p>You can do similar things with the other \"get\" or \"get_new\" routes, but this is just a small example. We wouldn't be able to do this for any of the \"set\" routes because you can't really send a json payload through just your browser, and you would have to use an external tool.</p>"},{"location":"telemetry_server/telemetry_server_api_routes/#route-definitions","title":"<p> Route Definitions </p>","text":""},{"location":"telemetry_server/telemetry_server_api_routes/#boat-status-routes","title":"<p> Boat Status Routes </p>","text":"<p>The boat status contains all of the useful telemetry that we can receive from the boat to understand what the boat is thinking. This can include sensor readings, state variables, or any other thing that would be useful to display to the user in real time. This relatively large JSON is being sent back and forth constantely, and if you want to reduce the LTE data that the boat is using, this would be the main place to focus on and optimize.</p> <p>The boat status has a very specific format whenever you are receiving or sending a \"boat status\". A boat status must be in the form of a dictionary with all of the following entries. This all must be wrapped in a \"value\" dictionary specifically because we need to be able to send the waypoints (a list) over json, and I wanted the format to be consistent among every route. We can change this in the future, the \"value\" dictionary was really just a bad decision that I just rolled with honestly. The motorboat needs to send the entries under General and Motorboat Specific and the sailboat needs to send the entries under General and Sailboat Specific:</p> <pre><code>{ \n    # General\n    \"position\": [0.0, 0.0], # longitude, latitude\n    \"state\": \"WAYPOINT_MISSION\", # a string that describes the autopilot mode that the boat is in. This can be Full_RC, Waypoint_Mission, Hold_Heading, etc etc. This depends heavily on how the specific autopilot sets it up though and these are just examples \n    \"speed\": 0.0, # speed in meters/second\n    \"velocity_vector\": [0.0, 0.0], # global velocity vector in m/s. [true east, true north]\n    \"bearing\": 0.0, # the angle to the next waypoint in degrees\n    \"heading\": 0.0, # describes the way the boat is rotated in degrees ccw from true east\n    \"rudder_angle\": 0.0, # the desired rudder angle in degrees\n    \"current_waypoint_index\": 0, # the index of the current waypoint. The autopilot is given a list of waypoints, and the autopilot will attempt to follow them one by one. This variable tracks that and how many waypoints the autopilot has completed in the current route\n    \"distance_to_next_waypoint\": 0.0, # the distance to the next waypoint in meters\n\n    # Sailboat Specific: \n    \"full_autonomy_maneuver\": \"CW_TACKING\", # mainly used for the sailboat to describe whether or not we are tacking and how we are tacking (ccw or cw tack) \n    \"true_wind_speed\": 0.0, # true wind speed in m/s \n    \"true_wind_angle\": 0.0, # true wind angle in degrees\n    \"apparent_wind_speed\": 0.0, # apparent wind speed in m/s\n    \"apparent_wind_angle\": 0.0, # apparent wind angle in degrees\n    \"sail_angle\": 0.0, # the desired sail angle in degrees\n\n    # Motorboat Specific:\n    \"vesc_telemetry_data_rpm\": self.vesc_telemetry_data_rpm, # the current revolutions per minute of the motor\n    \"vesc_telemetry_data_duty_cycle\": self.vesc_telemetry_data_duty_cycle, # the duty cycle from 0 to 1 of the motor\n    \"vesc_telemetry_data_amp_hours\": self.vesc_telemetry_data_amp_hours, # the amount of battery life (measured in amp hours) that have been used since the VESC booted up\n    \"vesc_telemetry_data_amp_hours_charged\": self.vesc_telemetry_data_amp_hours_charged, # the amount of battery life (measured in amp hours) that the battery still has? I am actually not too sure about this but whatever. \n    \"vesc_telemetry_data_current_to_vesc\": self.vesc_telemetry_data_current_to_vesc, # the average current in amps that is being transmitted to the VESC from the battery\n    \"vesc_telemetry_data_voltage_to_motor\": self.vesc_telemetry_data_voltage_to_motor, # the average voltage in volts that is being transmitted to the motor from the VESC\n    \"vesc_telemetry_data_voltage_to_vesc\": self.vesc_telemetry_data_voltage_to_vesc, # the average voltage in volts that is being transmitted to the VESC from the battery\n    \"vesc_telemetry_data_wattage_to_motor\": self.vesc_telemetry_data_wattage_to_motor, # the power in watts that is being transmitted to the motor\n    \"vesc_telemetry_data_time_since_vesc_startup_in_ms\": self.vesc_telemetry_data_time_since_vesc_startup_in_ms, # the time since the VESC has booted up\n    \"vesc_telemetry_data_motor_temperature\": self.vesc_telemetry_data_motor_temperature, # The current temperature of the motor \n    \"vesc_telemetry_data_vesc_temperature\": self.vesc_telemetry_data_vesc_temperature # The current temperature of the VESC\n\n}\n</code></pre> <p><code>/boat_status/get</code> Accessing this route will allow you to get the current status of the boat as a dictionary. This will be the last dictionary that has been sent to the telemetry server.</p> <p>This route is primarily accessed by the groundstation</p> <p></p> <p><code>/boat_status/get_new</code> Gets latest boat status dictionary if the latest boat status hasn't already been seen. If the latest boat status has been seen, then simply send an empty dictionary. This helps save on LTE data since we aren't sending data to the groundstation it has already seen it.</p> <p>This route is primarily accessed by the groundstation</p> <p></p> <p><code>/boat_status/set</code> Sets the boat status of the boat with the JSON thats passed to the route as a JSON payload.</p> <p>This route is primarily accessed by the telemetry node on the Jetson on the boat</p> <p></p> <p></p>"},{"location":"telemetry_server/telemetry_server_api_routes/#autopilot-parameter-routes","title":"<p> Autopilot Parameter Routes </p>","text":"<p>These autopilot parameters represent everything about the boat's behaviour that we may want to tweak from the groundstation while the boat is on the water. If we did not have autopilot parameters, then to slightly tweak some small parameters, we would need to ssh into the boat, change the code, and restart the main systemctl process.</p> <p>The default autopilot parameters are primarily defined in the src/autopilot/autopilot/config folder, which is what the boat uses whenever a new autopilot parameter hasn't been specified through this route. The following is what a JSON message to the telemetry server would look like if you would like to set new parameters:</p> <pre><code>{\n    \"sail_lookup_table_wind_angles\":    [0,    45,   90,   135,   180,   225,   270,   315,   360],\n    \"sail_lookup_table_sail_positions\": [70.0, 50.0, 30.0, 10.0,  0.0,   10.0,  30.0,  50.0,  70.0],\n\n    \"perform_forced_jibe_instead_of_tack\": true,\n    \"waypoint_accuracy\": 5,\n    \"tack_distance\": 100 \n}\n</code></pre> <p>This JSON will only contain the parameters that you would like to change, and you can only change the parameters that exist in the src/autopilot/autopilot/config folder. If you are reading parameters off of the /autopilot_parameters/get route, then you will receive all of the parameters including the ones that the groundstation has not manually changed. If you are reading parameters off of the /autopilot_parameters/get_new route, then you will only receive the parameters that have most recently changed (if they have not already been read already). No matter which route you are pulling the parameters off of, however, the format will be pretty much identical.</p> <p>Here is an example to help you understand what these routes should look like when implemented. In this example, these calls to the API routes are happening sequentially:</p> <p>on the telemetry node: POST autopilot_parameters/set_defaults: json={\u201ca\u201d: 1, \u201cb\u201d: 2}</p> <p>on the groundstation: POST autopilot_parameters/set: json={\u201ca\u201d: 3}</p> <p>GET autopilot_parameters/get would return {\u201ca\u201d: 3, \u201cb\u201d: 2} </p> <p>GET autopilot_parameters/get_defaults would return {\u201ca\u201d: 1, \u201cb\u201d: 2}</p> <p>GET autopilot_parameters/get_new would return {\u201ca\u201d: 3}</p> <p>GET autopilot_parameters/get_new a second time would return {}</p> <p><code>/autopilot_parameters/get</code> Accessing this route will allow you to get all of the parameters that the boat is currently using. This is useful if on the groundstation you would like to pull all of the parameters that the boat is currently using so that you can show the user what the boat is thinking. You can also use this as a more data intensive version of /autopilot_parameters/get_new on the telemetry node.</p> <p>This route can be accessed by either the groundstation or the telemetry node on the Jetson on the boat</p> <p></p> <p><code>/autopilot_parameters/get_new</code> Accessing this route will allow you to get the autopilot_parameters of the boat as a dictionary. This will be equivalent to the last JSON that has been sent to the telemetry server through the /autopilot_parameters/set route if it has not already been read. If the /autopilot_parameters/get_new route has already been read from and no new autopilot parameters were set, then this route will just return an empty JSON to save on LTE data.</p> <p>This route is primarily accessed by the telemetry node on the Jetson on the boat</p> <p></p> <p><code>/autopilot_parameters/set</code> Sets the autopilot parameters for the boat with the JSON thats passed to the route. You can send a JSON with just one autopilot parameter that you would like to change or you can change all of the autopilot_parameters at once. It is up to you.</p> <p>This route is primarily accessed by the groundstation</p> <p></p> <p><code>/autopilot_parameters/set_default</code> Sets the default parameters that the telemetry node is using. These are the same parameters that are in the src/autopilot/autopilot/config folder and should only be set once while the telemetry node is booting up and gives the telemetry server and the groundstation an idea of what parameters the boat is using if you haven't manually set certain parameters. This also tells you which parameters that you can set via /autopilot_parameters/set, since you can't add any other parameters other than the default parameters.</p> <p>This route is primarily accessed by the telemetry node on the Jetson on the boat</p> <p></p> <p><code>/autopilot_parameters/get_default</code> Views the default parameters that the telemetry node has been using. This is the same JSON as the JSON sent by the /autopilot_parameters/set_default route.</p> <p>This route is primarily accessed by the groundstation</p> <p> </p>"},{"location":"telemetry_server/telemetry_server_api_routes/#waypoint-routes","title":"<p> Waypoint Routes </p>","text":"<p>This route is how we send waypoints to the boat from the groundstation. Once the boat receives the waypoints, it will attempt to capture those waypoints in order. Capturing a waypoint means that the boat has gotten a certain amount of meters away from the waypoint; the exact number of meters away from the waypoint the boat has to be is defined in the \"waypoint_accuracy\" autopilot parameter. If the boat is sent another waypoint while it still hasn't finished its current mission, then it will abandon its previous route and start again at waypoint 1 on the route it was just sent. </p> <pre><code>{\n    \"waypoints\": [\n        [0.1221313, 0.21312],    # latitude, longitude of waypoint 1\n        [0.3213121, -0.313111],    # latitude, longitude of waypoint 2\n        # .... etc etc\n    ]\n}\n</code></pre> <p><code>/waypoints/get</code> Gets the current waypoint route that the boat should be currently trying to follow. This would be the same JSON as the last JSON that has been sent by the /waypoints/set route.</p> <p>This route is primarily accessed by the telemetry node on the Jetson on the boat via a GET request.</p> <p></p> <p><code>/waypoints/get_new</code> Gets latest waypoints if the latest waypoints haven't already been seen. If the latest waypoints have been seen, then simply send an empty dictionary. This helps save on LTE data since we aren't sending data to the boat if it has already seen it.</p> <p>This route is primarily accessed by the telemetry node on the Jetson on the boat via a GET request.</p> <p></p> <p><code>/waypoints/set</code> Sets the waypoints via a JSON payload. Make sure that you use the format provided above for the JSON that you send to the telemetry server or else the boat/ the telemetry node will not understand what to do.</p> <p>This route is primarily accessed by the groundstation as a POST request.</p> <p></p> <p><code>/waypoints/delete</code> This is a deprecated route that is no longer required and is probably bad practice to use. But what it used to do was delete the last waypoint entry so that /waypoints/get would return an empty set until you set new waypoints, but this is almost always better done using /waypoints/get_new, so you shouldn't really bother with this.</p> <p>This route would be accessed via a POST request.  </p>"},{"location":"telemetry_server/telemetry_server_api_routes/#faq","title":"<p> FAQ </p>","text":""},{"location":"telemetry_server/telemetry_server_api_routes/#i-am-still-confused-about-the-get_new-routes","title":"<p> I am still confused about the get_new routes </p>","text":"<p>This is likely best explained with an example: If you set the waypoints once from the groundstation, then those waypoints get stored in the telemetry server. How we have it set up right now, the telemetry node will constantly poll every 0.5 seconds for the new waypoints. You can imagine that if we are always sending back a large list of data, that would eat up our LTE data and cost us more money, so to optimize that, we would only like to send the waypoints to the telemetry node if there is something new for it to see. If there isnt, then we should just send an empty JSON because that uses the least amount of LTE data.</p> <p>The autopilot parameters are slightly different because we have 1 extra distinction when using get vs get_new for the autopilot parameters. When using get on the autopilot parameters, it will send all of the parameters regardless of if they were changed in the last call to set. However, if you use get_new it will only return the JSON payload in the last call to \"set\" and if you access it more than once, it will send over an empty JSON.</p>"},{"location":"telemetry_server/telemetry_server_overview/","title":"<p> Telemetry Server Overview </p>","text":"<p>As shown above, both the telemetry node and the groundstation will communicate with the telemetry server to send and receive information about the boat. The telemetry server is implemented as a Python Flask API that both the groundstation and the telemetry node on the jetson use as an intermediary to exchange messages.</p>"},{"location":"telemetry_server/telemetry_server_overview/#future-plans","title":"<p> Future Plans </p>","text":"<p>In the future, we would like to support having multiple boats/ simulations talking to the telemetry server at the same time. The end goal of this is to have the groundstation be able to choose which boat to connect to so you can receive telemetry data and send parameters to a specific boat thats currently active.</p> <p>In the future, we will want to make this API more RESTful which means that we need to remove everything that we are storing in memory and instead store data in specific databases. This way, if the server goes down, the information will still be present since it is stored in the filesystem instead of in RAM. </p>"}]}