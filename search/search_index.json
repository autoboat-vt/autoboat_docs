{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<p> Welcome to the Virginia Tech Sailbot and PEP Documentation!</p>","text":"<p>This document will outline how to set up the software stack on theoretically any modern computer. For more information on how to run simulations, testing, and how to run this code on the Jetson, please refer to the other docs.</p> <p></p>"},{"location":"#what-is-the-purpose-of-this-document","title":"<p> What Is the Purpose of This Document? </p>","text":"<p>The purpose of this document is to be an installation guide, overview of all of the technologies that we use, a description of how the software works, and a guide to how to use the software all in one! This is basically, in professional terms, an ICD, and the upkeep of this document is of paramount importance as this is the best and most efficient way to facilitate knowledge transfer between senior members of the club and newer members.</p> <p></p>"},{"location":"#how-do-i-get-started","title":"<p> How Do I Get Started? </p>","text":"<p>Head over to the Getting Started part of the documentation and complete the installation steps over at Installing Docker to install Docker. Then, complete the installation steps found in Setting Up the Development Container, and once you have the development container all set up, you should be ready to test everything! To get a simple simulation scenario up and running, then please visit Examples. </p> <p></p>"},{"location":"#what-frameworks-and-tools-should-i-learn","title":"<p> What Frameworks and Tools Should I Learn? </p>","text":"<p>Note</p> <p>TLDR: You should absolutely be familiar with ROS2 Humble and Git before you start working on this codebase. You may also want to learn Docker since it is extremely widely used and may be useful to know, but this is not necessary to work on the codebase.</p> <p>ROS2: Our techstack utilizes ROS2 (The Robotics Operating System) at its core. Unlike its name implies, it is not an actual operating system, but rather a middleware wrapper that makes concurrency and communication between sensor, actuators, autopilots, and telemetry super easy! This is the industry standard for projects just like this one so if you ever want to do anything in robotics, then this is the framework to learn! The specific version we are using is ROS2 Humble Hawksbill or ROS2 Humble for short, and the documentation for it can be found right here: ROS2 Humble Documentation. Specifically, I would recommend heading to the Tutorials and Concepts sections as those are the most useful for beginners. In addition, there is a really good video series outlining how to get started and do stuff with ROS in addition to the concepts, which can be found here: ROS2 Tutorial Series EP1.</p> <p>Git: This should be fairly self explanatory, but git and github are extremely important to learn if you want to work on any codebase. Make sure you specifically understand the concepts behind and how to stage, commit, push, pull, clone, merge, resolve merge conflicts, reset to a previous commit, and setup new branches. </p> <p>Docker: While this isn't much of a framework, it is still an important tool and understanding how it works and the concepts behind it, will make troubleshooting if you ever run into problems a bit easier. Docker is seen pretty much everywhere in software nowadays because its a super streamlined and fast way to create custom virtual machines. It really doesn't matter which part of the software industry you would like to work in in the future, I guarantee you that you will run into docker into some point. So it's better to learn it sooner rather than later! Heres some links to documentation and videos: - Docker Overview - Docker Video Explanation 1 - Docker Video Explanation 2 </p> <p>It turns out that Docker can be used for more than just deployment though. Relatively recently, Docker introduced full support for something called Docker Development Environments (Or Docker Development Containers), which allows us to do all of our development through a Docker container right inside VSCode! Thats great because getting ROS2 and our entire project working on everyone's computers and operating systems was a nightmare to orchestrate and setup, now everyone can just install Docker and our custom development container and start developing instantly! Additionally, there are plenty of other IDEs that support integration with development containers in case you use something other than VSCode; however, VSCode is what we will focus on in this document's setup instructions.</p>"},{"location":"crontabs/","title":"<p> Crontabs </p>","text":""},{"location":"crontabs/#what-are-crontabs","title":"<p> What are Crontabs? </p>","text":"<p>Crontabs are simply processes that linux makes run periodically. If we want to run a specific command every 5 seconds, then this is the way to do it. I encourage you to check out the crontabs documentation: Crontab Man Page (Official Documentation) and Third Party Crontab Tutorial.</p>"},{"location":"crontabs/#allowing-devices-to-always-be-accessed-by-non-sudo-users-chmod777jobtxt","title":"<p> Allowing Devices to Always be Accessed by Non-Sudo Users: chmod777job.txt</p>","text":"<p>Lets say, that you would like to test the GPS on your laptop inside of the dev container. You would plug the GPS in and then linux automatically will create a file called /dev/ttyACM01 or some other name for the file that linux decides. We can control what the file is called and override the linux default, but that is outside of the scope of this part of the documentation. Critically, this file represents the GPS, and the only way to communicate and read/ write over the GPS USB port is to access this file. However, by default, you may or may not actually have access to this file as a normal user on the linux system, and sometimes, the only person who has access to this file is the sudo or admin user. So, whenever you would like to communicate with the GPS from your computer and run the GPS node, you will have to run the following command:</p> <pre><code>sudo chmod 777 /dev/**\n</code></pre> <p>This command essentially just steps in as an admin user and says that \"as an admin user, I allow all other users to do whatever they want to the GPS, read or write, I don't care. This is simplifying a little bit, but I hope it gets the point across. Normally, we would need to run this command everytime we plug in the GPS to our computers; however, there is an easier way. We can instead set it up so that this command runs every 0.5 seconds so that when you plug it in, and by the time you try to interact with the GPS, the command will very likely have already been run. This concept applies to all USB devices that you would like to plug into your computer, but I just used the GPS as a simple example.</p>"},{"location":"known_installation_issues/","title":"<p> Known Issues</p>","text":"<ul> <li> <p>In order to get full Intellisense, you need to restart the dev container after building it. Idk how to fix this man but just go with it. The issue might be that the Docker dev environment doesn't register the .vscode folder when it first starts up which is interesting... not sure how I would go about fixing it if thats the issue.</p> </li> <li> <p>If the groundstation gives the following error when you boot it up:   then run the following command in a WSL terminal if you are on windows, or on a linux terminal if you are on linux: </p> </li> </ul> <pre><code>echo \"xhost + &gt;&gt; /dev/null\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc\n</code></pre> <p>Explanation for the groundstation error:  your host operating system may not allow you to open x servers from inside of docker because \"technically its a security vulnerability\", but if you have not realized yet, security is our -1st (last) priority here so we don't care. \"xhost +\" allows anyone to access your x server which lets them do whatever they want to your display, listen to keyboard inputs, etc. This command simply adds \"xhost +\" to your ~/.bashrc file, which is a series of bash commands that are run whenever your terminal opens. Then, the script runs the ~/.bashrc file to apply the changes.  \"&gt;&gt; /dev/null\" simply makes it so that the command doesn't print anything; this is not necessary at all but is nice so you don't have to see the same message everytime you open a terminal. </p>"},{"location":"standards_and_definitions/","title":"<p> Standards and Definitions</p>","text":""},{"location":"standards_and_definitions/#definitions","title":"Definitions:","text":"<ul> <li> <p>Autopilot Mode: Autopilot mode typically refers to whether or not the autopilot is in RC control, a semi-autonomous mode like hold heading, or in a full autonomous mode. This is just a string that describes the autopilot mode for the telemetry.</p> </li> <li> <p>Full Autonomy Maneuver: The full autonomy maneuver is only really used for the sailboat in a fully autonomous mode. This describes whether the boat is currently tacking clockwise, tacking counterclockwise, or is normally sailing and navigating towards a specific heading.</p> </li> </ul>"},{"location":"standards_and_definitions/#wind-angle-vector-standards","title":"Wind Angle/ Vector Standards","text":""},{"location":"standards_and_definitions/#todo","title":"TODO","text":"<ul> <li>Global True Wind Angle:</li> <li>True Wind Angle:</li> <li>Apparent Wind Angle:</li> </ul> <p>TODO: autopilot mode vs full autonomy maneuver, apparent wind angle vs true wind angle vs global true wind angle and their corresponding vectors</p>"},{"location":"examples/adding_a_new_ros2_node/","title":"<p> Adding a New ROS2 Node to A Package </p>","text":""},{"location":"examples/adding_a_new_ros2_node/#python-nodes","title":"Python Nodes","text":"<p>There are some really good tutorials online found here: Creating a ROS Node Tutorial, What is a ROS Topic, Creating a ROS Publisher Node, Creating a ROS Subscriber Node, and Combining a ROS Subscriber with a ROS Publisher. </p> <p></p> <p>This tutorial series is very good in general, and I would recommend looking at all the videos in the series although it is not strictly necessary.</p>"},{"location":"examples/adding_a_new_ros2_package/","title":"<p> Adding a New ROS2 Package to the Workspace </p>","text":""},{"location":"examples/adding_a_new_ros2_package/#python-packages","title":"Python Packages","text":"<p>To create a new ROS2 python package, you should first run the following command in the <code>/home/ws/src</code> folder:</p> <pre><code>ros2 pkg create &lt;Your Package Name Here&gt; --build-type ament_python --dependencies rclpy\n</code></pre> <p>Once you have created your package, you should see a new folder pop up in <code>/home/ws/src</code> that looks a little bit like this:</p> <p></p> <p>A more comprehensive tutorial can be found here: Comprehensive tutorial on how to create a ROS2 python package</p> <p></p> <p>Once you have the ROS2 python package created, you should make your way to the next section on adding new ROS2 nodes, where we will talk about how to add new nodes to ROS2 python packages.</p>"},{"location":"examples/how_we_handle_external_libraries/","title":"<p> How to Add External Libraries that We Can Edit</p>","text":"<p>Sometimes, we would like to use external pip packages, but still be able to edit the source code for them on the fly. One great example of this is the pyvesc library for the VESC node, where there are some minor differences between what the library does by default and what we want the library to do. In order to acheieve this, we will take advantage of the \"-e\" option in pip install, which allows us to install a local pip package as editable. Taking the example of the pyvesc library, here is how the source code is laid out:</p> <p></p> <p>Inside of the vesc ros2 package, we have the pyvesc library, which is very similar to the copy of the pyvesc library you can find here: Official pyvesc Library. This is where we would normally like to place our custom pip packages since it is easy to find what pip packages each ros2 package would like to use. Also, whenever you clone a git repository, it generates a folder named .git which contains all of the history of the repository. In short, we don't care about the history of the repository and in fact keeping this file makes it more annoying to use it in our codebase by automatically creating a nested repository. Nested repositories can become a nightmare to deal with, so to make all of our lives easier, just delete the .git folder. You can do so by using the rm -rf command:</p> <pre><code>rm -rf src/vesc/pyvesc/.git\n</code></pre> <p>Now that we have that working, we will need to make it so that we automatically install that package whenever someone runs <code>bash docker_dev_environment_setup.sh</code>. So, we need to add a line into the docker_dev_environment_setup.sh file like so:</p> <p></p> <p>This will automatically install the local pip package in editable mode, so if you make a change in the code of the pip package, then it will automatically reflect in any code that uses that package. If we did not have it in editable mode, then we would need to rebuild the package everytime we make a change to the source code. Now, to install the pip package, simply rerun <code>bash docker_dev_environment_setup.sh</code> and it should be ready to import in any python script inside of the dev container!</p>"},{"location":"examples/running_a_custom_simulation/","title":"<p> Running A Custom Simulation </p>","text":"<p>NOTE: Do Not Clone the Code into Your Docker Development Environment</p> <p>Make sure you clone this repository outside of the Docker development environment, because Docker gets a little fussy with building Docker images inside of a Docker Container, and I would rather not have to deal with that. If you are on Windows, this means that you should do the rest of the setup steps in WSL.</p> <p>You should only care about this installation process if you care about modifying and doing direct development on the gazebo simulation. Following these steps will allow you to modify and test a new simulation environment with modified parameters or code.  </p> <p>Before we can build a custom simulation, first we need to clone the sailbot_simulation repository.</p> <p>Open up a terminal in the folder you would like to place the code to build a new simulation in. Next type the following commands:</p> <pre><code>git clone https://github.com/sailbot-vt/sailbot_simulation \ncd sailbot_simulation\n</code></pre> <p>Now that you have all of the code on your computer, there is only 1 dependency for working with the simulation and that is docker-buildx. You can install it like this on Windows WSL and Ubuntu:</p> <pre><code>sudo apt install docker-buildx\n</code></pre> <p>mac OS Users</p> <p>If you are on mac OS, you will need to install docker-buildx using the following command:</p> <pre><code>brew install docker-buildx\n</code></pre> <p>Make sure to follow the instructions that brew gives you after running this command to make sure that docker-buildx is properly installed on your system.</p> <p>Now, all you have to do to build the simulation now is type in the following command:</p> <pre><code>sudo bash build_sim.sh\n</code></pre> <p>And thats it! Now automatically, the simulation node will instead use the new, custom simulation instead of the default. The simulation itself is quite poorly documented so if you have any questions about it and how to do certain things, please ask Chris.</p> <p>If you would like to go back to using the default simulation then all you have to do is delete the simulation docker image and repull the default simulation docker container, the simulation node will pull the default simulation image and build it.</p>"},{"location":"examples/running_individual_nodes/","title":"<p> Running Individual Nodes for Testing </p>","text":"<p>Sometimes it may be preferable to run each node in a separate terminal, so that you can get cleaner debug messages. If you would like to do this, then all of the commands to run each individual node are included in the documentation for that node.</p>"},{"location":"examples/running_simulation/","title":"<p> Running the Simulation </p>","text":"<p>To run the simulation, run the following commands in order after setting up the development container:</p> <pre><code>sudo docker pull aanimated/sailbot_simulation:latest\n</code></pre> <pre><code>ros2 launch /home/ws/src/launch/simulation.launch.py\n</code></pre> <p>This command will then start the simulation and autopilot. Initially, however they won't do anything because they don't have any waypoint commands, so what you will need to do is go into your ground station folder in another terminal (not in the dev container) and type in the following command:  </p> <pre><code>cd ground_station\n</code></pre> <pre><code>./run.sh\n</code></pre> <p>Next, click on \"zoom to boat\". This should show you where the boat is currently located (likely longitude 0 and latitude 0 since this is the default location)</p> <p>Now, click somewhere on the map and then click \"Send Waypoints\". This should cause the boat on screen to start moving and indicates that you have correctly set everything up!  </p>"},{"location":"getting_started/adding_documentation/","title":"<p> Adding Documentation </p>","text":"<p>As a team, we want our software and hardware decisions well-documented and kept in one place to ensure that new members can easily learn the big and complex system they work with, as well as quickly be plugged into development process. As such, after achieving a significant milestone, it is highly recommended to document it and contribute to this website. It is a lot easier than it sounds.</p> <p>To start, install the necessary dependencies. You do not have to do it in docker.</p> <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre> <p>Then, clone the github repository: <pre><code>git clone -b https://github.com/sailbot-vt/sailbot_docs\n</code></pre></p> <p>You may now make changes to the website code. To edit an existing page, simply find its .md file in <code>docs</code> and edit the text inside. To add a new page, add the file into whichever folder you want it to be (or create a new folder), type it up, and then include in <code>mkdocs.yml</code> under the nav section. The documentation supports html, markdown, and several extensions. You can read about the extensions here.</p> <p>To put your changes on the website, run: <pre><code>    mkdocs build\n    mkdocs serve\n</code></pre></p> <p>This will set the website to run locally on the <code>http://127.0.0.1:8000/</code> (localhost) IP address. To access it, just type that link in the web-browser.</p> <p>After you feel good about your changes, deploy them to the internet: <pre><code>    mkdocs gh-deploy\n</code></pre></p> <p>And don't forget to push them to the github repository!</p>"},{"location":"getting_started/installing_docker/","title":"<p> Installing Docker </p>","text":"<p>NOTE: If You Meet Difficulties Installing Docker</p> <p>Ensure that you meet Docker's system requirements listed on their documentation, if not then attempt to contact an officer or look through the Docker documentation for what to do if you do not meet the system requirements.</p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-windows","title":"<p> Installing Docker on Windows </p>","text":"<p>In order to install Docker on windows, first we must install WSL (Windows Subsystem in Linux).</p> <p>Open the command prompt with administrator privileges and type the following commands:</p> <pre><code>wsl.exe --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <p>Enter your user info to complete the installation.  </p> <p>With these steps, this will have installed WSL and Ubuntu 22.04. Docker requires Ubuntu WSL to work on Windows. For more information see the official WSL documentation: Official WSL Documentation.</p> <p>Next, we must install the Docker desktop application and connect it up to WSL.  </p> <p>The following link contains the download link for Docker desktop on Windows. Follow the download instructions, and when you are done, you should have Docker installed! Docker Desktop for Windows Install Page</p> <p>You may run into permission issues with docker, so you need to run the following commands in your WSL terminal to give your non-sudo user access to Docker.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-ubuntu-linux","title":"<p> Installing Docker on Ubuntu Linux </p>","text":"<p>Please type the following sets of commands in a terminal.</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <pre><code># Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-mac-os","title":"<p> Installing Docker on Mac OS </p>","text":"<p>Docker can be installed standalone from the website, but it is recommended to instead install via Homebrew, the unofficial official package manager for Mac OS. Homebrew is recommended over the standalone installer as it simplifies the installation process and is nice to use.</p> <p>Please install Homebrew by entering the following command into the terminal</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Now that Homebrew is installed, run the following command to install Docker Desktop</p> <pre><code>brew install --cask docker\n</code></pre> <p>To verify that the installation was successful, run the following command</p> <pre><code>docker version\n</code></pre> <p>If the installation succeeded, you should get something along the lines of the following</p> <pre><code>\u276f docker version\nClient:\n Version:           27.0.3\n API version:       1.46\n Go version:        go1.21.11\n Git commit:        7d4bcd8\n Built:             Fri Jun 28 23:59:41 2024\n OS/Arch:           darwin/arm64\n Context:           desktop-linux\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-other-operating-systems","title":"<p> Installing Docker on Other Operating Systems </p>","text":"<p>Documentation for the rest of the operating systems docker supports can be found here: Official Docker Installation Instructions for Every OS.</p>"},{"location":"getting_started/installing_microros/","title":"<p> Installing MicroROS </p>","text":"<p>To create a layer of protection between Jetson and high voltages, and extend the number of GPIO pins we have access to, we use an RP2040 microcontroller, which communicates via a serial connection. Luckily, we are able to extend our software infrastructure to it through the microros platform. It runs nodes directly on the microcontroller, and then allows them to publish and listen on topics through the USB serial connection. Due to resource-restricted nature of the microcontrollers, the code is written in C and many of the principles when writing nodes for Jetson are inapplicable.</p> <p>To install microros on your machine, navigate to <code>/src/microros/</code> and run the following command. Note that the installation will take approximately 5 GB:</p> <pre><code>    bash microros_setup.sh\n</code></pre> <p>Don't forget to source your ~/.bashrc file:</p> <pre><code>    source ~/.bashrc\n</code></pre> <p>Note</p> <p>Notice that you need to establish communication between Pi Pico and WSL by USB to flash it. If you are on Windows, download and install the latest release of USB support software from WSL USB GUI Releases. By default, devices are not automatically shared with WSL, so you will need to manually autoattach.</p> <p>To flash Pi Pico with a .uf2 file, plug Pico into your computer while pressing the Boot Select button (you may release it after Pi Pico is in) and run: <pre><code>    picotool_load #write/the/address/of/your/file/here\n</code></pre></p> <p>The Pi Pico cannot communicate with the computer while it is in Boot Select mode. To exit it, you can uplug it and replug it from the USB port. Alretnatively, you may run: <pre><code>    picotool_reboot -F\n</code></pre></p> <p>Then, to establish communication with Pi Pico, run the following commands:</p> <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre> <p>If you encounter problems during the installation, consult Elias.</p>"},{"location":"getting_started/installing_microros/#running-the-example-code","title":"<p> Running the Example Code </p>","text":"<p>If you want to get started with microros, a good idea would be to try to flash Pi Pico with the example file. Note that you would need to build it first: <pre><code>    cd $PICO_MICROROS_SDK_PATH\n    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n    picotool_load pico_micro_ros_example.uf2\n</code></pre></p> <p>Then, proceed to open the serial communication: <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre></p> <p>And finally, open a new terminal, and type <pre><code>    source ~/.bashrc\n    ros2 topic list\n</code></pre></p> <p>If you have done everything correctly, <code>/pico_publisher</code> would show up in the list of topics. You can watch its output by typing:</p> <pre><code>    ros2 topic echo /pico_publisher\n</code></pre>"},{"location":"getting_started/setting_up_dev_environment/","title":"<p> Before Setting Up the Dev Environment </p>","text":"<p>Make sure that you have installed Docker before doing this step. The following steps will not work if Docker is not installed on your machine. The easiest way to check whether docker is installed correctly, open a terminal and type <code>docker</code>. If an error doesn't pop up that means that you can proceed!</p> <p>mac OS Users</p> <p>In order for the simulation window to appear, you must install XQuartz as macos does not come with a x11 server. Please run the following command in your terminal:</p> <pre><code>brew install --cask xquartz\n</code></pre> <p>After installation, please follow these steps:</p> <ol> <li>Launch XQuartz. Under the XQuartz menu, select Settings.</li> <li>Go to the Security tab and ensure \"Allow connections from network clients\" is checked.</li> <li>Restart XQuartz.</li> </ol> <p>Also ensure that you have VSCode or some other IDE that supports Docker dev environments installed (If you are using Windows you install VSCode in WSL too). For the purposes of this documentation, we will be using VSCode but there are plenty of other IDEs that support this and they each have their own documentation for how to get this setup.</p>"},{"location":"getting_started/setting_up_dev_environment/#installing-the-development-container","title":"<p> Installing the Development Container </p>","text":"<ul> <li> <p>First, (If you are using Windows you must do this in a WSL folder) we need to clone the main Github repository from the following URL: https://github.com/sailbot-vt/sailbot_vt. Open up a terminal and type the following command:</p> <p><code>git clone https://github.com/sailbot-vt/sailbot_vt</code></p> </li> <li> <p>Then, open up that folder in VSCode by typing the following into the same terminal:</p> <p><code>cd sailbot_vt &amp;&amp; code .</code></p> </li> <li> <p>Install the Docker Dev Containers Extension on VSCode. It should look like the following: </p> </li> </ul> <p>mac OS Users</p> <p>Before building the container, make sure that XQuartz is open and that you have run the following command in your terminal: <code>xhost localhost</code></p> <p>To test whether or not XQuartz is working correctly, run either <code>xeyes</code> or <code>xclock</code> in your terminal. Your should see a new window appear with one of the following images.</p> <p><p></p></p> <p>If you see one of these images, then XQuartz is working correctly.</p> <ul> <li>Build and enter dev container for the repo by typing in the following into the search bar at the top <code>&gt;dev containers build</code>. You should see something similar to this at the top: . Wait for a moment as the container sets itself up!</li> </ul>"},{"location":"getting_started/setting_up_dev_environment/#final-setup-after-loading-development-container","title":"<p> Final Setup after Loading Development Container </p>","text":"<p>Once you are inside your development container, go to the terminal and input the following command.</p> <pre><code>bash docker_dev_environment_setup.sh &amp;&amp; source ~/.bashrc\n</code></pre> <p>mac OS Users</p> <p>To test the connection to the Docker container, run the following commands in the terminal in the Docker container:</p> <pre><code>sudo apt-get install -y x11-apps\nxeyes\n</code></pre> <p>If you see a new window with eyes, then the connection is working correctly.</p> <p>Restart VSCode by closing it and reopening it to make sure all of the changes refresh properly.</p>"},{"location":"getting_started/setting_up_dev_environment/#connecting-back-to-the-dev-container","title":"<p> Connecting Back to The Dev Container </p>","text":"<p>If you would like to close the container and resume development on it some other time then heres how you do that. First, open a VSCode window and click on the search bar at the very top. Instead of searching like you would normally, instead type <code>&gt;open folder in container</code>. Remember to include the \"&gt;\" as thats what allows your VSCode search bar to run commands. Once you do that you should get a popup that looks something like this:</p> <p></p> <p>Click on Dev Containers: Open Folder in Container. This should navigate you to a file explorer. Using it, simply navigate to the folder that you cloned the github repo into and you should be back to your development container.</p>"},{"location":"getting_started/what_did_you_just_install/","title":"<p> What is Docker and How Does it Work? </p>","text":"<p>Docker is essentially a way to share custom (super fast) virtual machines. A Dockerfile is the instructions to create these virtual machines. These are then compiled into Docker Images which are the virtual machines stopped at whatever point the Dockerfile told it to stop at. When you run a Docker Image, you get a Docker Container. A Docker Container is the actual virtual machine that you can interact with and work with.  </p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-is-a-development-container-and-why-are-we-using-one","title":"<p> What is a Development Container and Why are We Using One? </p>","text":"<p>A Development Container is a just a Docker Container that already has all of the requirements to start developing, so you can skip setup and not worry about operating system specific software. There are a lot of software packages we rely on and some of the software that we use only works on certain versions on Ubuntu and is really hard to get your hands on with other operating systems. Docker Development Containers automate the process of installing everything by creating a Docker Image with everything installed and running that. This allows you to start developing instantely! Additionally this helps automate and streamline deployment on the Nvidia Jetson microprocessor.</p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-about-the-ground-station","title":"<p> What About the Ground Station? </p>","text":"<p>This code is supposed to be run on an operator's computer to control the boat while it is on the water by telling a cloud server what we want our boat to do. The boat (specifically the telemetry node) then listens to this cloud server, processes the data, and performs whatever action we told it to do. You can do various things like sending different parameters to the autopilot and sending waypoints. These parameters can look like the PID gains or the tacking distance or the size of the no go zone etc (in other words things that were chosen arbitrarily).</p> <p>You can also use the ground station code to control the simulation, so if you send waypoints or parameters while a simulation is running then the simulation will automatically listen to the cloud server and navigate to those waypoints/ change specific parameters.</p> <p>For more information on how the ground station sends parameters, please see the resources section of the documentation.</p>"},{"location":"hardware/squircuit/","title":"<p> Squircuit </p>","text":"<p>Squircuit is the name of our PCB in development. It is intended to decrease the amount of wiring we have to do. The squircuit contains three buck converters for three different power lines (5V, 9V, and 15~20V), two slots for motor controllers, a relay driver, fuses, and the outputs. The images below show the layout of the entire crcuit as well as the pinout of specifically Pi Pico.</p> <p></p> <p></p>"},{"location":"hardware/wiring_color_scheme/","title":"<p> Wiring Color Schemes </p>","text":"<p>In order to efficiently wire our numerous peripheral devices, we decided to use a coloring standard that will simplify identifying what wire belongs to what interface.</p> Interface Pin Color General Power \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 GND \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 I2C SCL \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SDA \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 UART RX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 TX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SPI SCLK \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MISO \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MOSI \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 CS \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0"},{"location":"misc/potential_security_risks/","title":"Heres where I put potential security risks which don't matter at all right now but may matter in the future.","text":"<p>In the future though if we ever want to open source this and release it as a tool for others to use or a product, this would be where to start. - dev container uses docker.sock which needs to have permissions granted to it. So I just do it through ~/.bashrc - <code>sailbot_user ALL=(ALL) NOPASSWD: chmod</code> is appended to /etc/sudoers when building the image. This is not the safest lol</p> <p>Please contact chris (animated__ through discord) if you want to change these things but don't know if we are at a stage where you should/ how to do it</p>"},{"location":"nodes/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/","title":"<p> Autopilot Nodes </p>","text":""},{"location":"nodes/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#summary","title":"Summary","text":"<p>These nodes are responsible for listening to data about the current state of the boat and a set of waypoints and publishing the desired motor behaviour based on our autopilot software. These nodes run completely asynchronously on an internal timer, which means that a few times every seconds it runs a non-blocking script to calculate what the desired motor behaviours should be and publishes them when its done. This node does not actually have code to communicate with motors directly, but instead lets the microcontroller figure out the specifics of how to communicate with the motor.</p> <p>Additionally, these nodes publish data that is useful for telemetry and debugging such as the the current maneuver it is attempting to perform and what its desired heading is currently.</p> <p>An important thing to note is that these nodes also control basic RC override, which is why they need to listen into the raw RC data. There are several different types of RC override listed below:  TODO: make this actually documented lol</p> <p></p>"},{"location":"nodes/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#the-autopilot-parameters-system","title":"The Autopilot Parameters System","text":"<p>In order for us to be able to control and tune parameters for the autopilot from the groundstation, these nodes also listen for autopilot_parameters. These are jsons (serialized as strings) which detail all of the new parameters and what their values should be. These values are sent from the groundstation to the telemetry server, then to the telemetry node and then finally to the autopilot (a diagram of how exactly this is done can be found in the system diagrams). An example of these parameters is shown below:  </p> <p>Not all of the parameters need to be included in the json. If only some of the parameters are included, then only those parameters will get changed in the autopilot. The default parameters can be found in the config folder and whenever a parameter is not specified by the groundstation, it will default to the parameter values found in the config folder. Also, the default parameter files in the config folder represent all of the parameters that the autopilot can accept, so if you are ever curious about which parameters you can change in the autopilot, then please check out the default parameters files.</p> <p></p>"},{"location":"nodes/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#choosing-the-correct-rudder-angle","title":"Choosing the Correct Rudder Angle","text":"<p>One of the tasks that the autopilot aims to do is to choose the correct rudder angle, so that our boats can follow a certain heading. A lot of the time, this isn't so simple because of how non-linear this problem ends up being. So, we choose to use a PID controller to be flexible enough to handle non-linearity, while still having the option to revert back to a simple proportional controller. </p> <p></p> <p>If you are lost on any of the controls terminology, then I would recommend that you look at some of the following resources: Proportional Controller Tutorial and PID Controller Introduction. These resources are just a start, and if you would like to work on the autopilot, I would highly recommend you look more into basic control theory and become intimately familiar with how these work. </p>"},{"location":"nodes/gps/","title":"<p> GPS </p>","text":""},{"location":"nodes/gps/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our GPS (Sparkfun NEO-M8P-2) and using various filtering techniques to clean the data and make it less noisy. Our GPS gives us both position and velocity data by tracking satellites in the sky, so performance may vary depending on how cloudy it is. </p> <p>We use the sparkfun-ublox-gps pip package to communicate with the gps, although in the future, we could look into the pyubx2 library as that seems to have more features. </p> <p>In the future we may also want to look into RTK (real time kinematics) to increase our GPS accuracy, but even without that, our GPS module is really precise with 0.5 meter accuracy! RTK would be nice though because it allows us to apply less aggressive filtering techniques and still get good results.</p>"},{"location":"nodes/microros/","title":"<p> Microros </p>","text":"<p>This is the main package for MicroROS development. Due to the nature of microcontrollers, only one package can be run on a Pi Pico. However, there are few limitations as to how many nodes can be run. Since the RP2040 chip installed on Pi Pico has two cores, we can even run some of the nodes in parallel, taking full advantage of multithreading. All of the nodes will be documented in this file. To get started with microros development, check out Installing MicroROS in misc.</p> <p>All the nodes, their common resources, execution order, and scheduling are managed in the main.c file in the src folder. If you want to add a .c file with a node, as well as in add_executable section in CMakeLists.txt. Depends on if you include new libraries you might want to add them in CMakeLists.txt too. Important libraries and ports are located in common_microros_libs.h, which is preferable to include in each file within src folder. If you need to define ports or pins, UART for example, you do it there. To build an already existing project, execute the following commands inside <code>/microros/</code> (not <code>/microros/src/</code>): <pre><code>    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n</code></pre> From here on, after making changes to the code, you can build it simply by running <code>make</code>. Next steps, such as opening communication with ROS or flashing Pico are detailed in Installing MicroROS. </p>"},{"location":"nodes/motorboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"nodes/motorboat_autopilot/#what-is-the-should_propeller_motor_be_powered-topic","title":"What is the should_propeller_motor_be_powered topic?","text":"<p>This topic basically turns off a contactor that denies power to the propeller motor. This is implemented for safety, since we would like to know whether the high voltage system and the propeller motor is live whenever we want to swap out propellers or move the boat. </p>"},{"location":"nodes/motorboat_autopilot/#why-does-the-autopilot-node-control-whether-the-contactor-should-be-closed-cant-the-raspberry-pi-pico-directly-receive-rc-data-and-then-control-the-contactor","title":"Why does the Autopilot Node Control Whether the Contactor Should be Closed. Can't the Raspberry Pi Pico Directly Receive RC Data and then Control the Contactor?","text":"<p>We would like the contactor to be controlled by RC command primarily, but we would also like to support the idea that in the future, we may want the autopilot to complete a route, and then unpower itself so that we can take it out of the water safely without having to manually depower it via RC. Another reason is that the raspberry pi pico code is a little harder to change, and if we wanted to change which toggle the contactor switch/ kill switch would be tied to (or really any of the RC buttons), we could theoretically do that through autopilot parameters and the groundstation. This is ideal, but also not implemented yet. Also, if we must make the decision that the raspberry pi pico must listen to the RC data topic at all, that means that there will be a lot of serial port traffic over the usb port to the raspberry pi pico, since the jetson needs to send the entirety of the RC data struct many many times per second. This may eat up CPU time on both the Jetson and the Pico and make them both less responsive (sort of). The CPU time is kind of a pedantic reason and really we would want to benchmark and see whether this actually makes any meaningful difference.</p> <p>TLDR: this is kinda just how I chose to do it since all of the other RC functions are described in the autopilot and all of the reasons above are retroactive cope</p>"},{"location":"nodes/object_detection/","title":"<p> Object Detection </p>","text":""},{"location":"nodes/object_detection/#summary","title":"Summary","text":"<p>This node is responsible for detecting buoys and baoats while in the water, which includes calculating the angle and distance. To detect the buoys, our system uses a computer vision model based on Ultralytics Yolo11. We use the Ultralytics  results object to retrieve any information about object detections. We also use ROS2 to publish the angle to the buoy, the depth distance to the buoy as well as a list of detection results that involve the cnofidence value, relative x-position, and relative y-position of the detrected bounding boxes.</p>"},{"location":"nodes/rc/","title":"<p> RC (Remote Controller) </p>","text":""},{"location":"nodes/rc/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our RC (remote controller). The remote controller that we use is the Radiomaster TX12 and the receiver that we use is the Radiomaster ER6. The communication protocol that we use is called CRSF with ExpressLRS, and we use the crsf_parser pip package to help us parse the crsf frames (frames are just a fancy way to say message packets).</p> <p>Here are some resources to understand the CRSF protocol: </p> <p>Useful reddit thread</p> <p>Source Code for an Arduino CRSF Parser</p> <p>:p Yeah thats it, there aren't many good resources unfortunately.</p> <p>If you would like to have some more resources on the receiver and transmitter they are available here:</p> <p>ER6 Receiver User Manual</p> <p>TX12 Quickstart Guide</p> <p>TX12 Transmitter User Manual</p> <p>Misc Radiomaster Documentation Collection (not necessary unless we want to buy another radiomaster product)</p>"},{"location":"nodes/sailboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"nodes/sailboat_autopilot/#choosing-the-best-sail-angle","title":"Choosing the Best Sail Angle","text":"<p>As it turns out, for any apparent wind angle, there is an optimal sail angle that you should turn the sail to. This is perhaps the only simple thing about the autopilot. There are plenty of diagrams such as the one below that demonstrate what those optimal sail angles are: </p> <p></p> <p>As long as the sail angle follows this pattern for the sail angle, then the boat will be moving the fastest in that direction. To accomplish this, we use a lookup table that linearly interpolates between the optimal sail angles given in the sail lookup table (which is described in the autopilot parameters):</p> <p> </p> <p>The code works by taking the two closest wind angles and their corresponding closest sail angles, then we construct a line out of that and figure out where we fall along that line. This is called linear interpolation. </p>"},{"location":"nodes/sailboat_autopilot/#how-do-we-sail-upwind","title":"How Do We Sail Upwind?","text":"<p>You may be wondering, how is the boat able to sail slightly upwind in the sailing diagram. Well, this is a neat quirk of sailing that is the entire reason why sailing is even possible in the first place. If we are able to hold an angle right outside of this \"no sail zone\", then we are able to gain some ground going upwind, and if we can go in a zig zag motion upwind, then we are able to move upwind and not make any net progress to the side. Here is a video that visually explains how it works: Sailing Tutorial Video. Skip to 23:00 if you want the tacking explanation, but the entire video is pretty good, so I would recommend watching all of it.</p>"},{"location":"nodes/sailboat_autopilot/#how-do-we-determine-when-to-tack","title":"How Do We Determine When to Tack?","text":"<p>A very simple way to tack is to check whether the waypoint is in the no sail zone. If the waypoint is in the no sail zone, then keep a close hauled position (it doesn't matter too much whether you keep close hauled to the left of the waypoint or to the right of the waypoint). The boat will then keep that close hauled position until the waypoint goes out of the no sail zone, and then the boat will tack towards the waypoint and successfully capture the waypoint. This method will ensure that the boat will have to tack exactly once to get to its destination. A visual represntation of what this looks like is shown below:</p> <p></p> <p>To determine when to tack, we have to introduce a concept called decision zones. This concept doesn't really exist anywhere online because we invented it for autonomous tacking. Essentially if we create another zone inside of the nogo zone called the decision zone and pay attention to the line between the boat and the next waypoint, then whenever the line between the boat and the next waypoint is in \"zone 1\" then we should hold a tack on the left side of the wind. Whenever the line between the boat and the next waypoint is in \"zone 3\" then we should hold a tack on the right side of the wind. Finally, if the line is in zone 2, you should continue holding the tack that you were previously holding. A visual representation of the decision zone and what a path when using decision zone tacking can both be found below:</p> <p></p> <p></p> <p>So then that begs the question, how large should the decision zone be. Well a couple of years ago, we had some team members derive the theoretically optimal decision zone size if you want to go a specific distance before tacking. This formula can be found below:</p> <p></p> <p>This formula is not perfect and can often be very wrong due to factors like noisy sensor data, the wind shifting, the boat drifting due to water currents, etc; however, it provides a good baseline for us to use in our algorithm.</p> <p>Using the decision zone tacking strategy and constantely updating the size of our decision zone, we can efficiently sail upwind!</p>"},{"location":"nodes/sailboat_simulation/","title":"<p> Sailboat Simulation </p>","text":""},{"location":"nodes/sailboat_simulation/#summary","title":"Summary","text":"<p>The simulation node simulates all of the real world interactions that the boat will undergo without having to put the boat on the water. The simulation essentially takes the place of all of the sensor nodes and the microros nodes and should publish/ subscribe to the same things as those nodes. For more information on how the simulation interacts with everything else, please look at the system diagram for ros nodes for the simulation.</p>"},{"location":"nodes/sailboat_simulation/#how-it-works","title":"How it Works","text":"<p>The simulation node is basically a wrapper around the sailboat_gym repository, which can be found here: Sailboat Gym Github Repository. This repository basically has a docker container that all of the actual simulations happen in because there is a gazebo simulator for the sailboat inside of the docker container. The sailboat_gym repository then communicates with the docker container and controls the sailboat that exists inside of the docker container. The docker container is based off of the following repository: USV Sim LSA Github Repository, which is the gazebo environment that is run inside of the docker container. We can actually edit the docker container ourselves and have our own custom versions of the simulation, which is what I have set up the following repository for: Our Sailboat Simulation. In this github repository, you can edit the code for the simulation and then rebuild the docker image to be used whenever you use the simulation node. For more information, please look at the running a custom simulation documentation. You should also check out the system diagram for the simulation stack as it provides a visual explanation for how all of these pieces of code interact with each other.</p> <p>The simulation node simply imports the sailboat_gym repository and then ties specific actions to publishers and subscribers. For instance, if you publish a sail and rudder command, then the simulation node will pass that onto the sailboat_gym repository which will correspondingly control the boat in the simulation.</p>"},{"location":"nodes/sailbot_msgs/","title":"<p> Sailbot Messages </p>","text":""},{"location":"nodes/sailbot_msgs/#summary","title":"Summary","text":"<p>This package contains various custom messages types that nodes would need to send to each other! Try to add messages to the custom messages library sparingly as we would like most nodes to only publish/ listen with a message type in the base ros2 messages. Here is a list of all of the standard messages that I would recommend using. This keeps our code easily compatible with other peoples' drivers so we can just drop in other peoples' drivers if we ever need to.</p> <p></p>"},{"location":"nodes/sailbot_msgs/#contains-the-following-messages","title":"Contains the Following Messages","text":"<p>RCData: A standardized way to send RC Data based on the Radiomaster TX12 buttons. Includes both joysticks and all switches/ buttons</p> <p>WaypointList: A list of NavSatFix objects (https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/NavSatFix.html) that represents a list of waypoints. These are passed around and then interpretted by the autopilot to figure out how it should move to get to those waypoints.</p> <p>VESCControlData: Contains all of the data that you need to send in order to command the vesc</p> <p>VESCTelemetryData: Telemetry data from the VESC that gives us feedback about how fast the motor is spinning, how much voltage/ current is being used, etc</p> <p>ObjectDetectionResult: Contains a confidence value and an xy position for the object that the computer vision model found</p> <p>ObjectDetectionResultsList: A list of ObjectDetectionResults</p>"},{"location":"nodes/telemetry/","title":"<p> Telemetry </p>","text":""},{"location":"nodes/telemetry/#summary","title":"Summary","text":"<p>This node is responsible for listening to various topics and sending the data to the telemetry server so that we, on the ground, can view the data. Additionally, this node is also responsible for listening to autopilot parameters and waypoints stored in the telemetry server and sending them to the autopilot node. This allows us to change parameters of the autopilot and change the waypoints the boat needs to follow from the shore.  </p> <p>The telemetry node listens to data about the boats current state such as the position, velocity, heading, apparent wind vector. It also listens in on data that lets us know what the autopilot is currently thinking such as the current sail/ rudder angle, the heading it is trying to sail towards, a list of all of the waypoints that it is trying to follow, an index that represents what waypoint the autopilot is currently on, the name of the mode the autopilot is currently on (whether it is in RC mode, full autonomy mode, or some semi-autonomous mode), and the maneuver the boat might be trying to perform if it is in full autonomous mode (like tacking/ jibing).</p>"},{"location":"nodes/vesc/","title":"<p> VESC (Vedder Electric Speed Controller) </p>","text":""},{"location":"nodes/vesc/#what-is-a-vesc","title":"What is a VESC?","text":"<p>A VESC is one type of electric speed controller, which regulate the speed and power that goes into our big propeller motor. VESCs are really only used for our motorboats, since motor controllers like these are usually overkill for the smaller motors in our sailboat. The big advantage of using a VESC controller instead of any random ESC controller is that the VESC firmware (which is the main thing that characterizes a VESC controller) provides a standardized way to send and receive complex control messages and telemetry data. It also has a lot of functionality built into the firware to allow for you to change voltage limits, shut-off voltages, PID constant values, encoder configurations, etc etc all from your computer or your phone via bluetooth. You can even change these things on the fly through custom software you can write. This is great! this means that we can write software to communicate with one ESC, and we guaranteed that it will work on another ESC that is running the VESC firmware. We are also assured that we can get a plethora of telemetry data back from a VESC on how much voltage our battery has, how much voltage/ current/ power is going to our motor, how much RPM our motor has, the temperature of our motor, etc.</p> <p>If it is not obvious yet, VESC is great and we would like to mainly buy VESC compatible ESCs whenever we would like to spec an ESC for a certain motor and desired system power. If you would like to read more about the wonders of VESC, you can do so here: VESC Tutorial and Other VESC Tutorial. If you would like to download VESC Tool which is the software that you can download on your computer or phone to configure and control the VESC without the VESC Node, you can do so here: VESC Tool Download.</p>"},{"location":"nodes/vesc/#how-does-the-vesc-node-work","title":"How Does the VESC Node Work","text":"<p>The VESC node works by using an open source library called pyvesc, which is a python implementation that allows us to send and receive messages from the VESC over the USB serial port. The original pyvesc github can be found here: pyvesc github, and the documentation can be found here: pyvesc documentation</p> <p>For this project, we may want to modify the pyvesc library slightly to better suit our needs, so we have a modified version of the pyvesc library set up inside of the vesc package folder. Check out the documentation on custom libraries to learn more about how we use custom libraries in our ROS workspace.</p> <p>The VESC Node simply takes in ROS2 messages for the VESC control struct, and sends that information to the VESC controller whenever it receives the data from the autopilot. Meanwhile, the node also reads telemetry data from the VESC at a set interval and publishes it back out so that any node can listen in on the RPM, power, etc of the motor.</p> <p>I will go into a little bit of depth in how the VESC control struct works since it isn't completely obvious how it works. The VESC control struct has the following entries:</p> <p></p> <p>string control_type_for_vesc</p> <p>float32 desired_vesc_current</p> <p>float32 desired_vesc_rpm</p> <p>float32 desired_vesc_duty_cycle</p> <p></p> <p>The \"control_type_for_vesc\" can take on the following values: \"rpm\", \"duty_cycle\", or \"current\". Each of these are different ways to control the propeller motor by telling the VESC what you want the desired RPM to be, telling the VESC what you want the duty cycle (basically voltage to the motor) to be, or telling the VESC what you want the current to the motor to be. The VESC's job is to use the control type and your desired values, and get as close to that as possible; for the purposes of this project, how it does that is basically magic. </p> <p>If control_type_for_vesc is \"rpm\", then the only other entry in the struct that matters is the \"desired_vesc_rpm\" entry which tells the motor what the desired RPM is. All other entries are basically ignored. The same happens with the rest of the control types. So to summarize, only 2 of the entries in the struct ever matter at one time, and it depends on the value of the \"control_type_for_vesc\" string.</p>"},{"location":"nodes/what_about_the_other_nodes/","title":"<p> TLDR </p>","text":"<p>For all the other nodes in the repository, don't worry about them for now. They are likely just tests or very highly under development. Either way you shouldn't worry about them on a conceptual level for now, just focus on understanding how the nodes that are documented work and developing on those unless explicitly told otherwise.</p>"},{"location":"nodes/what_about_the_other_nodes/#ntrip-client","title":"<p> NTRIP Client </p>","text":"<p>This node is designed to take RTCM messages from a local RTCM provider and publish them out so our gps can use them as correctional data. The node is currently fully functional; however, we haven't yet figured out how to get the gps to register the messages properly. That is what the official gps node is for.</p>"},{"location":"nodes/what_about_the_other_nodes/#official-gps","title":"<p> Official GPS </p>","text":"<p>This is a clone of the official ROS driver for our GPS series. The reason we did not use this from the start was a result of some weird choices Chris made for containerizing the entire project that didn't work with these drivers. This node works very similarly to our current GPS node; it simply listens for a GPS to plug into the device and publishes the results to a ROS topic. This ROS node, however has some other useful functionalities such as the ability to receive RTCM messages and use them as correctional data for our GPS.</p>"},{"location":"nodes/wind_sensor/","title":"<p> Wind Sensor </p>","text":""},{"location":"nodes/wind_sensor/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our wind sensor (Calypso Wind Sensor). The wind sensor gives us NMEA0183 sentences that look may look like the picture below. </p> <p></p> <p>The NMEA0183 message structure is very simple. The basics are that they always send a \"$\" when the message starts and separates different sub-messages with commas. If you would like to read more about NMEA0183, you can do so here: NMEA0183 explanation.</p> <p></p> <p>Our wind sensor device sends its sub-messages in the following order: </p>"},{"location":"system_diagrams/diagram_of_groundstation_telemetry/","title":"<p> Flow of Information Between Groundstation and Autopilot Node </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Flow of Telemetry Information Between Groundstation and Autopilot Node Source File Download</p>"},{"location":"system_diagrams/diagram_of_ros_nodes/","title":"<p> How Nodes Interact on the Sailboat Simulation </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat Simulation Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-sailboat-on-real-hardware","title":"<p> How Nodes Interact on the Sailboat on Real Hardware</p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat on Real Hardware Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-motorboat-on-real-hardware","title":"<p> How Nodes Interact on the Motorboat on Real Hardware </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Motorboat on Real Hardware Node Diagram Source File Download</p>"},{"location":"system_diagrams/diagram_of_simulations/","title":"<p> How Each of the Different Codebases Contributing to the Simulation Interact </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Simulation Diagram Source File Download</p>"}]}