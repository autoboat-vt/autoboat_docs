{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<p> Welcome to the Virginia Tech Sailbot and PEP Documentation!</p>","text":"<p>This document will outline how to set up the software stack on theoretically any modern computer. For more information on how to run simulations, testing, and how to run this code on the Jetson, please refer to the other docs.</p> <p></p>"},{"location":"#what-is-the-purpose-of-this-document","title":"<p> What Is the Purpose of This Document? </p>","text":"<p>The purpose of this document is to be an installation guide, overview of all of the technologies that we use, a description of how the software works, and a guide to how to use the software all in one! This is basically, in professional terms, an ICD, and the upkeep of this document is of paramount importance as this is the best and most efficient way to facilitate knowledge transfer between senior members of the club and newer members.</p> <p></p>"},{"location":"#how-do-i-get-started","title":"<p> How Do I Get Started? </p>","text":"<p>Head over to the Getting Started part of the documentation and complete the installation steps over at Installing Docker to install Docker. Then, complete the installation steps found in Setting Up the Development Container, and once you have the development container all set up, you should be ready to test everything! To get a simple simulation scenario up and running, then please visit Examples. </p> <p></p>"},{"location":"#what-frameworks-should-i-learn","title":"<p> What Frameworks Should I Learn? </p>","text":"<p>ROS2: Our techstack utilizes ROS2 (The Robotics Operating System) at its core. Unlike its name implies, it is not an actual operating system, but rather a middleware wrapper that makes concurrency and communication between sensor, actuators, autopilots, and telemetry super easy! This is the industry standard for projects just like this one so if you ever want to do anything in robotics, then this is the framework to learn! The specific version we are using is ROS2 Humble Hawksbill or ROS2 Humble for short, and the documentation for it can be found right here: ROS2 Humble Documentation. Specifically, I would recommend heading to the Tutorials and Concepts sections as those are the most useful for beginners. In addition, there is a really good video series outlining how to get started and do stuff with ROS in addition to the concepts, which can be found here: ROS2 Tutorial Series EP1.</p> <p>Docker: While this isn't much of a framework, it is still an important tool and understanding how it works and the concepts behind it, will make troubleshooting if you ever run into problems a bit easier. Docker is seen pretty much everywhere in software nowadays because its a super streamlined and fast way to create custom virtual machines. It really doesn't matter which part of the software industry you would like to work in in the future, I guarantee you that you will run into docker into some point. So it's better to learn it sooner rather than later! Heres some links to documentation and videos: - Docker Overview - Docker Video Explanation 1 - Docker Video Explanation 2 </p> <p>It turns out that Docker can be used for more than just deployment though. Relatively recently, Docker introduced full support for something called Docker Development Environments (Or Docker Development Containers), which allows us to do all of our development through a Docker container right inside VSCode! Thats great because getting ROS2 and our entire project working on everyone's computers and operating systems was a nightmare to orchestrate and setup, now everyone can just install Docker and our custom development container and start developing instantly! Additionally, there are plenty of other IDEs that support integration with development containers in case you use something other than VSCode; however, VSCode is what we will focus on in this document's setup instructions.</p>"},{"location":"known_issues/","title":"<p> Known Issues</p>","text":"<ul> <li> <p>In order to get full Intellisense, you need to restart the dev container after building it. Idk how to fix this man but just go with it. The issue might be that the Docker dev environment doesn't register the .vscode folder when it first starts up which is interesting... not sure how I would go about fixing it if thats the issue.</p> </li> <li> <p>If the groundstation gives the following error when you boot it up:   then run the following command in a WSL terminal if you are on windows, or on a linux terminal if you are on linux: </p> </li> </ul> <pre><code>echo \"xhost + &gt;&gt; /dev/null\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc\n</code></pre> <p>Explanation for the groundstation error:  your host operating system may not allow you to open x servers from inside of docker because \"technically its a security vulnerability\", but if you have not realized yet, security is our -1st (last) priority here so we don't care. \"xhost +\" allows anyone to access your x server which lets them do whatever they want to your display, listen to keyboard inputs, etc. This command simply adds \"xhost +\" to your ~/.bashrc file, which is a series of bash commands that are run whenever your terminal opens. Then, the script runs the ~/.bashrc file to apply the changes.  \"&gt;&gt; /dev/null\" simply makes it so that the command doesn't print anything; this is not necessary at all but is nice so you don't have to see the same message everytime you open a terminal. </p>"},{"location":"examples/running_a_custom_simulation/","title":"Running A Custom Simulation","text":"<p>NOTE: Do Not Clone the Code into Your Docker Development Environment</p> <p>Make sure you clone this repository outside of the Docker development environment, because Docker gets a little fussy with building Docker images inside of a Docker Container, and I would rather not have to deal with that. If you are on Windows, this means that you should do the rest of the setup steps in WSL.</p> <p>You should only care about this installation process if you care about modifying and doing direct development on the gazebo simulation. Following these steps will allow you to modify and test a new simulation environment with modified parameters or code.  </p> <p>Before we can build a custom simulation, first we need to clone the sailbot_simulation repository.</p> <p>Open up a terminal in the folder you would like to place the code to build a new simulation in. Next type the following commands:</p> <pre><code>git clone https://github.com/sailbot-vt/sailbot_simulation \ncd sailbot_simulation\n</code></pre> <p>Now that you have all of the code on your computer, there is only 1 dependency for working with the simulation and that is docker-buildx. You can install it like this on Windows WSL and Ubuntu:</p> <pre><code>sudo apt install docker-buildx\n</code></pre> <p>mac OS Users</p> <p>If you are on mac OS, you will need to install docker-buildx using the following command:</p> <pre><code>brew install docker-buildx\n</code></pre> <p>Make sure to follow the instructions that brew gives you after running this command to make sure that docker-buildx is properly installed on your system.</p> <p>Now, all you have to do to build the simulation now is type in the following command:</p> <pre><code>sudo bash build_sim.sh\n</code></pre> <p>And thats it! Now automatically, the simulation node will instead use the new, custom simulation instead of the default. The simulation itself is quite poorly documented so if you have any questions about it and how to do certain things, please ask Chris.</p> <p>If you would like to go back to using the default simulation then all you have to do is delete the simulation docker image and repull the default simulation docker container, the simulation node will pull the default simulation image and build it.</p>"},{"location":"examples/running_individual_nodes/","title":"Running Individual Nodes for Testing","text":"<p>Sometimes it may be preferable to run each node in a separate terminal, so that you can get cleaner debug messages. If you would like to do this, then all of the commands to run each individual node are included in the documentation for that node.</p>"},{"location":"examples/running_simulation/","title":"Running the Simulation","text":"<p>To run the simulation, run the following commands in order after setting up the development container:</p> <pre><code>sudo docker pull aanimated/sailbot_simulation:latest\n</code></pre> <pre><code>ros2 launch /home/ws/src/launch/simulation.launch.py\n</code></pre> <p>This command will then start the simulation and autopilot. Initially, however they won't do anything because they don't have any waypoint commands, so what you will need to do is go into your ground station folder in another terminal (not in the dev container) and type in the following command:  </p> <pre><code>cd ground_station\n</code></pre> <pre><code>./run.sh\n</code></pre> <p>Next, click on \"zoom to boat\". This should show you where the boat is currently located (likely longitude 0 and latitude 0 since this is the default location)</p> <p>Now, click somewhere on the map and then click \"Send Waypoints\". This should cause the boat on screen to start moving and indicates that you have correctly set everything up!  </p>"},{"location":"getting_started/adding_documentation/","title":"<p> Adding Documentation </p>","text":"<p>As a team, we want our software and hardware decisions well-documented and kept in one place to ensure that new members can easily learn the big and complex system they work with, as well as quickly be plugged into development process. As such, after achieving a significant milestone, it is highly recommended to document it and contribute to this website. It is a lot easier than it sounds.</p> <p>To start, install the necessary dependencies. You do not have to do it in docker.</p> <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre> <p>Then, clone the github repository: <pre><code>git clone -b https://github.com/sailbot-vt/sailbot_docs\n</code></pre></p> <p>You may now make changes to the website code. To edit an existing page, simply find its .md file in <code>docs</code> and edit the text inside. To add a new page, add the file into whichever folder you want it to be (or create a new folder), type it up, and then include in <code>mkdocs.yml</code> under the nav section. The documentation supports html, markdown, and several extensions. You can read about the extensions here.</p> <p>To put your changes on the website, run: <pre><code>    mkdocs build\n    mkdocs serve\n</code></pre></p> <p>This will set the website to run locally on the <code>http://127.0.0.1:8000/</code> (local) IP address. To access it, just type that link in the web-browser.</p> <p>After you feel good about your changes, deploy them to the internet: <pre><code>    mkdocs gh-deploy\n</code></pre></p> <p>And don't forget to push them to the github repository!</p>"},{"location":"getting_started/installing_docker/","title":"<p> Installing Docker </p>","text":"<p>NOTE: If You Meet Difficulties Installing Docker</p> <p>Ensure that you meet Docker's system requirements listed on their documentation, if not then attempt to contact an officer or look through the Docker documentation for what to do if you do not meet the system requirements.</p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-windows","title":"<p> Installing Docker on Windows </p>","text":"<p>In order to install Docker on windows, first we must install WSL (Windows Subsystem in Linux).</p> <p>Open the command prompt with administrator privileges and type the following commands:</p> <pre><code>wsl.exe --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <p>Enter your user info to complete the installation.  </p> <p>With these steps, this will have installed WSL and Ubuntu 22.04. Docker requires Ubuntu WSL to work on Windows. For more information see the official WSL documentation: Official WSL Documentation.</p> <p>Next, we must install the Docker desktop application and connect it up to WSL.  </p> <p>The following link contains the download link for Docker desktop on Windows. Follow the download instructions, and when you are done, you should have Docker installed! Docker Desktop for Windows Install Page</p> <p>You may run into permission issues with docker, so you need to run the following commands in your WSL terminal to give your non-sudo user access to Docker.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-ubuntu-linux","title":"<p> Installing Docker on Ubuntu Linux </p>","text":"<p>Please type the following sets of commands in a terminal.</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <pre><code># Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-mac-os","title":"<p> Installing Docker on Mac OS </p>","text":"<p>Docker can be installed standalone from the website, but it is recommended to instead install via Homebrew, the unofficial official package manager for Mac OS. Homebrew is recommended over the standalone installer as it simplifies the installation process and is nice to use.</p> <p>Please install Homebrew by entering the following command into the terminal</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Now that Homebrew is installed, run the following command to install Docker Desktop</p> <pre><code>brew install --cask docker\n</code></pre> <p>To verify that the installation was successful, run the following command</p> <pre><code>docker version\n</code></pre> <p>If the installation succeeded, you should get something along the lines of the following</p> <pre><code>\u276f docker version\nClient:\n Version:           27.0.3\n API version:       1.46\n Go version:        go1.21.11\n Git commit:        7d4bcd8\n Built:             Fri Jun 28 23:59:41 2024\n OS/Arch:           darwin/arm64\n Context:           desktop-linux\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-other-operating-systems","title":"<p> Installing Docker on Other Operating Systems </p>","text":"<p>Documentation for the rest of the operating systems docker supports can be found here: Official Docker Installation Instructions for Every OS.</p>"},{"location":"getting_started/installing_microros/","title":"<p> Installing MicroROS </p>","text":"<p>To create a layer of protection between Jetson and high voltages, and extend the number of GPIO pins we have access to, we use an RP2040 microcontroller, which communicates via a serial connection. Luckily, we are able to extend our software infrastructure to it through the microros platform. It runs nodes directly on the microcontroller, and then allows them to publish and listen on topics through the USB serial connection. Due to resource-restricted nature of the microcontrollers, the code is written in C and many of the principles when writing nodes for Jetson are inapplicable.</p> <p>To install microros on your machine, navigate to <code>/src/microros/</code> and run the following command. Note that the installation will take approximately 5 GB:</p> <pre><code>    bash microros_setup.sh\n</code></pre> <p>Don't forget to source your ~/.bashrc file:</p> <pre><code>    source ~/.bashrc\n</code></pre> <p>Note</p> <p>Notice that you need to establish communication between Pi Pico and WSL by USB to flash it. If you are on Windows, download and install the latest release of USB support software from WSL USB GUI Releases. By default, devices are not automatically shared with WSL, so you will need to manually autoattach. If you are on MacOS... condolences.</p> <p>To flash Pi Pico with a .uf2 file, plug Pico into your computer while pressing the Boot Select button (you may release it after Pi Pico is in) and run: <pre><code>    picotool_load #write/the/address/of/your/file/here\n</code></pre></p> <p>The Pi Pico cannot communicate with the computer while it is in Boot Select mode. To exit it, you can uplug it and replug it from the USB port. Alretnatively, you may run: <pre><code>    picotool_reboot -F\n</code></pre></p> <p>Then, to establish communication with Pi Pico, run the following commands:</p> <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre> <p>If you encounter problems during the installation, consult Elias.</p>"},{"location":"getting_started/installing_microros/#running-the-example-code","title":"<p> Running the Example Code </p>","text":"<p>If you want to get started with microros, a good idea would be to try to flash Pi Pico with the example file. Note that you would need to build it first: <pre><code>    cd $PICO_MICROROS_SDK_PATH\n    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n    picotool_load pico_micro_ros_example.uf2\n</code></pre></p> <p>Then, proceed to open the serial communication: <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre></p> <p>And finally, open a new terminal, and type <pre><code>    source ~/.bashrc\n    ros2 topic list\n</code></pre></p> <p>If you have done everything correctly, <code>/pico_publisher</code> would show up in the list of topics. You can watch its output by typing:</p> <pre><code>    ros2 topic echo /pico_publisher\n</code></pre>"},{"location":"getting_started/setting_up_dev_environment/","title":"<p> Before Setting Up the Dev Environment </p>","text":"<p>Make sure that you have installed Docker before doing this step. The following steps will not work if Docker is not installed on your machine. The easiest way to check whether docker is installed correctly, open a terminal and type <code>docker</code>. If an error doesn't pop up that means that you can proceed!</p> <p>mac OS Users</p> <p>In order for the simulation window to appear, you must install XQuartz as macos does not come with a x11 server. Please run the following command in your terminal:</p> <pre><code>brew install --cask xquartz\n</code></pre> <p>After installation, please follow these steps:</p> <ol> <li>Launch XQuartz. Under the XQuartz menu, select Settings.</li> <li>Go to the Security tab and ensure \"Allow connections from network clients\" is checked.</li> <li>Restart XQuartz.</li> </ol> <p>Also ensure that you have VSCode or some other IDE that supports Docker dev environments installed (If you are using Windows you install VSCode in WSL too). For the purposes of this documentation, we will be using VSCode but there are plenty of other IDEs that support this and they each have their own documentation for how to get this setup.</p>"},{"location":"getting_started/setting_up_dev_environment/#installing-the-development-container","title":"<p> Installing the Development Container </p>","text":"<ul> <li> <p>First, (If you are using Windows you must do this in a WSL folder) we need to clone the main Github repository from the following URL: https://github.com/sailbot-vt/sailbot_vt. Open up a terminal and type the following command:</p> <p><code>git clone https://github.com/sailbot-vt/sailbot_vt</code></p> </li> <li> <p>Then, open up that folder in VSCode by typing the following into the same terminal:</p> <p><code>cd sailbot_vt &amp;&amp; code .</code></p> </li> <li> <p>Install the Docker Dev Containers Extension on VSCode. It should look like the following: </p> </li> </ul> <p>mac OS Users</p> <p>Before building the container, make sure that XQuartz is open and that you have run the following command in your terminal: <code>xhost localhost</code></p> <p>To test whether or not XQuartz is working correctly, run either <code>xeyes</code> or <code>xclock</code> in your terminal. Your should see a new window appear with one of the following images.</p> <p><p></p></p> <p>If you see one of these images, then XQuartz is working correctly.</p> <ul> <li>Build and enter dev container for the repo by typing in the following into the search bar at the top <code>&gt;dev containers build</code>. You should see something similar to this at the top: . Wait for a moment as the container sets itself up!</li> </ul>"},{"location":"getting_started/setting_up_dev_environment/#final-setup-after-loading-development-container","title":"<p> Final Setup after Loading Development Container </p>","text":"<p>Once you are inside your development container, go to the terminal and input the following commands.</p> <pre><code>bash docker_dev_environment_setup.sh\n</code></pre> <pre><code>source ~/.bashrc\n</code></pre> <p>mac OS Users</p> <p>To test the connection to the Docker container, run the following commands in the terminal in the Docker container:</p> <pre><code>sudo apt-get install -y x11-apps\nxeyes\n</code></pre> <p>If you see a new window with eyes, then the connection is working correctly.</p> <p>Restart VSCode by closing it and reopening it to make sure all of the changes refresh properly.</p>"},{"location":"getting_started/setting_up_dev_environment/#connecting-back-to-the-dev-container","title":"<p> Connecting Back to The Dev Container </p>","text":"<p>If you would like to close the container and resume development on it some other time then heres how you do that. First, open a VSCode window and click on the search bar at the very top. Instead of searching like you would normally, instead type <code>&gt;open folder in container</code>. Remember to include the \"&gt;\" as thats what allows your VSCode search bar to run commands. Once you do that you should get a popup that looks something like this:</p> <p></p> <p>Click on Dev Containers: Open Folder in Container. This should navigate you to a file explorer. Using it, simply navigate to the folder that you cloned the github repo into and you should be back to your development container.</p>"},{"location":"getting_started/what_did_you_just_install/","title":"<p> What is Docker and How Does it Work? </p>","text":"<p>Docker is essentially a way to share custom (super fast) virtual machines. A Dockerfile is the instructions to create these virtual machines. These are then compiled into Docker Images which are the virtual machines stopped at whatever point the Dockerfile told it to stop at. When you run a Docker Image, you get a Docker Container. A Docker Container is the actual virtual machine that you can interact with and work with.  </p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-is-a-development-container-and-why-are-we-using-one","title":"<p> What is a Development Container and Why are We Using One? </p>","text":"<p>A Development Container is a just a Docker Container that already has all of the requirements to start developing, so you can skip setup and not worry about operating system specific software. There are a lot of software packages we rely on and some of the software that we use only works on certain versions on Ubuntu and is really hard to get your hands on with other operating systems. Docker Development Containers automate the process of installing everything by creating a Docker Image with everything installed and running that. This allows you to start developing instantely! Additionally this helps automate and streamline deployment on the Nvidia Jetson microprocessor.</p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-about-the-ground-station","title":"<p> What About the Ground Station? </p>","text":"<p>This code is supposed to be run on an operator's computer to control the boat while it is on the water by telling a cloud server what we want our boat to do. The boat (specifically the telemetry node) then listens to this cloud server, processes the data, and performs whatever action we told it to do. You can do various things like sending different parameters to the autopilot and sending waypoints. These parameters can look like the PID gains or the tacking distance or the size of the no go zone etc (in other words things that were chosen arbitrarily).</p> <p>You can also use the ground station code to control the simulation, so if you send waypoints or parameters while a simulation is running then the simulation will automatically listen to the cloud server and navigate to those waypoints/ change specific parameters.</p> <p>For more information on how the ground station sends parameters, please see the resources section of the documentation.</p>"},{"location":"hardware/squircuit/","title":"<p> Squircuit </p>","text":"<p>Squircuit is the name of our PCB in development. It is intended to decrease the amount of wiring we have to do. The squircuit contains three buck converters for three different power lines (5V, 9V, and 15~20V), two slots for motor controllers, a relay driver, fuses, and the outputs. The images below show the layout of the entire crcuit as well as the pinout of specifically Pi Pico.</p> <p></p> <p></p>"},{"location":"hardware/wiring_color_scheme/","title":"<p> Wiring Color Schemes </p>","text":"<p>In order to efficiently wire our numerous peripheral devices, we decided to use a coloring standard that will simplify identifying what wire belongs to what interface.</p> Interface Pin Color General Power \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 GND \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 I2C SCL \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SDA \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 UART RX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 TX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SPI SCLK \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MISO \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MOSI \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 CS \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0"},{"location":"misc/potential_security_risks/","title":"Heres where I put potential security risks which don't matter at all right now but may matter in the future.","text":"<p>In the future though if we ever want to open source this and release it as a tool for others to use or a product, this would be where to start. - dev container uses docker.sock which needs to have permissions granted to it. So I just do it through ~/.bashrc - <code>sailbot_user ALL=(ALL) NOPASSWD: chmod</code> is appended to /etc/sudoers when building the image. This is not the safest lol</p> <p>Please contact chris (animated__ through discord) if you want to change these things but don't know if we are at a stage where you should/ how to do it</p>"},{"location":"nodes/gps/","title":"<p> GPS </p>","text":""},{"location":"nodes/gps/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our GPS (Sparkfun NEO-M8P-2) and using various filtering techniques to clean the data and make it less noisy. Our GPS gives us both position and velocity data by tracking satellites in the sky, so performance may vary depending on how cloudy it is. </p> <p>We use the sparkfun-ublox-gps pip package to communicate with the gps, although in the future, we could look into the pyubx2 library as that seems to have more features. </p> <p>In the future we may also want to look into RTK (real time kinematics) to increase our GPS accuracy, but even without that, our GPS module is really precise with 0.5 meter accuracy! RTK would be nice though because it allows us to apply less aggressive filtering techniques and still get good results.</p> <p></p>"},{"location":"nodes/gps/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> </ul>"},{"location":"nodes/microros/","title":"<p> Microros </p>","text":"<p>This is the main package for MicroROS development. Due to the nature of microcontrollers, only one package can be run on a Pi Pico. However, there are few limitations as to how many nodes can be run. Since the RP2040 chip installed on Pi Pico has two cores, we can even run some of the nodes in parallel, taking full advantage of multithreading. All of the nodes will be documented in this file. To get started with microros development, check out Installing MicroROS in misc.</p> <p>All the nodes, their common resources, execution order, and scheduling are managed in the main.c file in the src folder. If you want to add a .c file with a node, as well as in add_executable section in CMakeLists.txt. Depends on if you include new libraries you might want to add them in CMakeLists.txt too. Important libraries and ports are located in common_microros_libs.h, which is preferable to include in each file within src folder. If you need to define ports or pins, UART for example, you do it there. To build an already existing project, execute the following commands inside <code>/microros/</code> (not <code>/microros/src/</code>): <pre><code>    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n</code></pre> From here on, after making changes to the code, you can build it simply by running <code>make</code>. Next steps, such as opening communication with ROS or flashing Pico are detailed in Installing MicroROS. </p>"},{"location":"nodes/object_detection/","title":"<p> Object Detection </p>","text":""},{"location":"nodes/object_detection/#summary","title":"Summary","text":"<p>This node is responsible for detecting buoys and baoats while in the water, which includes calculating the angle and distance. To detect the buoys, our system uses a computer vision model based on Ultralytics Yolo11. We use the Ultralytics  results object to retrieve any information about object detections. We also use ROS2 to publish the angle to the buoy, the depth distance to the buoy as well as a list of detection results that involve the cnofidence value, relative x-position, and relative y-position of the detrected bounding boxes.</p> <p></p>"},{"location":"nodes/object_detection/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":"<ul> <li>/camera/camera/aligned_depth_to_color/image_raw (Image from sensor_msgs)</li> <li>/camera/camera/color/image_raw (Image from sensor_msgs)</li> </ul>"},{"location":"nodes/object_detection/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/buoy_angle (Float32 from std_msgs)</li> <li>/buoy_depth_pixel (Float32 from std_msgs)</li> <li>/object_detection_results (ObjectDetectionResultsList from sailbot_msgs)</li> </ul>"},{"location":"nodes/rc/","title":"<p> RC (Remote Controller) </p>","text":""},{"location":"nodes/rc/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our RC (remote controller). The remote controller that we use is the Radiomaster TX12 and the receiver that we use is the Radiomaster ER6. The communication protocol that we use is called CRSF with ExpressLRS, and we use the crsf_parser pip package to help us parse the crsf frames (frames are just a fancy way to say message packets).</p> <p></p>"},{"location":"nodes/rc/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/rc_data (RCData from sailbot_msgs)</li> </ul>"},{"location":"nodes/sailboat_autopilot/","title":"<p> Autopilot </p>","text":""},{"location":"nodes/sailboat_autopilot/#summary","title":"Summary","text":"<p>This node is responsible for listening to data about the current state of the boat and a set of waypoints and publishing the desired rudder and sail angles based on our autopilot software. This node runs completely asynchronously on an internal timer, which means that a few times every seconds it runs a non-blocking script to calculate what the desired rudder and sail angles should be and publishes them when its done.</p> <p>Additionally, this node publishes data that is useful for telemetry and debugging such as the the current maneuver it is attempting to perform and what its desired heading is currently.</p> <p>An important thing to note is that this node also controls basic RC override, which is why it needs to listen into the raw RC data. There are several different types of RC override listed below:  TODO: make this actually documented lol</p> <p></p>"},{"location":"nodes/sailboat_autopilot/#the-autopilot-parameters-system","title":"The Autopilot Parameters System","text":"<p>In order for us to be able to control and tune parameters for the autopilot from the groundstation, this node also listens for autopilot_parameters. These are jsons (serialized as strings) which detail all of the new parameters and what their values should be. These values are sent from the groundstation to the telemetry server, then to the telemetry node and then finally to the autopilot. An example of these parameters is shown below:  </p> <p>Not all of the parameters need to be included in the json. If only some of the parameters are included, then only those parameters will get changed in the autopilot.</p> <p></p>"},{"location":"nodes/sailboat_autopilot/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> <li>/heading (Float32 from std_msgs)</li> <li>/apparent_wind_vector (Vector3 from geometry_msgs)</li> <li>/autopilot_parameters (String from std_msgs)</li> <li>/rc_data (RCData from sailbot_msgs)</li> <li>/autopilot_mode (String from std_msgs)</li> <li>/waypoints_list (WaypointList from sailbot_msgs)</li> </ul>"},{"location":"nodes/sailboat_autopilot/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/full_autonomy_maneuver (String from std_msgs)</li> <li>/desired_heading (Float32 from std_msgs)</li> <li>/actions/sail_angle (Float32 from std_msgs)</li> <li>/actions/rudder_angle (Float32 from std_msgs)</li> </ul>"},{"location":"nodes/sailbot_msgs/","title":"<p> Sailbot Messages </p>","text":""},{"location":"nodes/sailbot_msgs/#summary","title":"Summary","text":"<p>This package contains various custom messages types that nodes would need to send to each other! Try to add messages to the custom messages library sparingly as we would like most nodes to only publish/ listen with a message type in the base ros2 messages. This keeps our code easily compatible with other peoples' drivers so we can just drop in other peoples' drivers if we ever need to.</p> <p></p>"},{"location":"nodes/sailbot_msgs/#contains-the-following-messages","title":"Contains the Following Messages","text":"<p>RCData: A standardized way to send RC Data based on the Radiomaster TX12 buttons. Includes both joysticks and all switches/ buttons</p> <p>WaypointList: A list of NavSatFix objects (https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/NavSatFix.html) that represents a list of waypoints. These are passed around and then interpretted by the autopilot to figure out how it should move to get to those waypoints.</p> <p>VESCControlData: Contains all of the data that you need to send in order to command the vesc</p> <p>VESCData: Telemetry data from the VESC that gives us feedback about how fast the motor is spinning, how much voltage/ current is being used, etc</p> <p>ObjectDetectionResult: Contains a confidence value and an xy position for the object that the computer vision model found</p> <p>ObjectDetectionResultsList: A list of ObjectDetectionResults</p>"},{"location":"nodes/simulation/","title":"<p> Simulation </p>","text":""},{"location":"nodes/simulation/#summary","title":"Summary","text":"<p>talk about building your own simulation gui and how to build sailboat-gym pip package from source talk about building your own gazebo simulation situation through the other repo</p> <p></p>"},{"location":"nodes/simulation/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":""},{"location":"nodes/simulation/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":""},{"location":"nodes/telemetry/","title":"<p> Telemetry </p>","text":""},{"location":"nodes/telemetry/#summary","title":"Summary","text":"<p>This node is responsible for listening to various topics and sending the data to the telemetry server so that we, on the ground, can view the data. Additionally, this node is also responsible for listening to autopilot parameters and waypoints stored in the telemetry server and sending them to the autopilot node. This allows us to change parameters of the autopilot and change the waypoints the boat needs to follow from the shore.  </p> <p>The telemetry node listens to data about the boats current state such as the position, velocity, heading, apparent wind vector. It also listens in on data that lets us know what the autopilot is currently thinking such as the current sail/ rudder angle, the heading it is trying to sail towards, a list of all of the waypoints that it is trying to follow, an index that represents what waypoint the autopilot is currently on, the name of the mode the autopilot is currently on (whether it is in RC mode, full autonomy mode, or some semi-autonomous mode), and the maneuver the boat might be trying to perform if it is in full autonomous mode (like tacking/ jibing).</p> <p></p>"},{"location":"nodes/telemetry/#listens-to-the-following-topics","title":"Listens to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> <li>/heading (Float32 from std_msgs)</li> <li>/apparent_wind_vector (Vector3 from geometry_msgs)</li> <li>/actions/sail_angle (Float32 from std_msgs)</li> <li>/actions/rudder_angle (Float32 from std_msgs)</li> <li>/desired_heading (Float32 from std_msgs)</li> <li>/waypoints_list (WaypointList from sailbot_msgs)</li> <li>/cur_waypoint_index (Int32 from std_msgs)</li> <li>/full_autonomy_maneuver (String from std_msgs)</li> <li>/autopilot_mode (String from std_msgs)</li> </ul>"},{"location":"nodes/telemetry/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/waypoints_list (WaypointList from sailbot_msgs)</li> <li>/autopilot_parameters (String from std_msgs)</li> </ul>"},{"location":"nodes/what_about_the_other_nodes/","title":"<p> TLDR </p>","text":"<p>For all the other nodes in the repository, don't worry about them for now. They are likely just tests or very highly under development. Either way you shouldn't worry about them on a conceptual level for now, just focus on understanding how the nodes that are documented work and developing on those unless explicitly told otherwise.</p>"},{"location":"nodes/what_about_the_other_nodes/#ntrip-client","title":"<p> NTRIP Client </p>","text":"<p>This node is designed to take RTCM messages from a local RTCM provider and publish them out so our gps can use them as correctional data. The node is currently fully functional; however, we haven't yet figured out how to get the gps to register the messages properly. That is what the official gps node is for.</p>"},{"location":"nodes/what_about_the_other_nodes/#official-gps","title":"<p> Official GPS </p>","text":"<p>This is a clone of the official ROS driver for our GPS series. The reason we did not use this from the start was a result of some weird choices Chris made for containerizing the entire project that didn't work with these drivers. This node works very similarly to our current GPS node; it simply listens for a GPS to plug into the device and publishes the results to a ROS topic. This ROS node, however has some other useful functionalities such as the ability to receive RTCM messages and use them as correctional data for our GPS.</p>"},{"location":"nodes/wind_sensor/","title":"<p> Wind Sensor </p>","text":""},{"location":"nodes/wind_sensor/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our wind sensor (Calypso Wind Sensor). The wind sensor gives us NMEA0183 sentences that look may look like the picture below. </p> <p></p> <p>The NMEA0183 message structure is very simple. The basics are that they always send a \"$\" when the message starts and separates different sub-messages with commas. If you would like to read more about NMEA0183, you can do so here: NMEA0183 explanation.</p> <p></p> <p>Our wind sensor sends its sub-messages in the following order: </p> <p></p>"},{"location":"nodes/wind_sensor/#publishes-to-the-following-topics","title":"Publishes to the Following Topics","text":"<ul> <li>/position (NavSatFix from sensor_msgs)</li> <li>/velocity (Twist from geometry_msgs)</li> </ul>"},{"location":"system_diagrams/diagram_of_groundstation_telemetry/","title":"<p> Flow of Information Between Groundstation and Autopilot Node </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Flow of Telemetry Information Between Groundstation and Autopilot Node Source File Download</p>"},{"location":"system_diagrams/diagram_of_simulations/","title":"Diagram of How the Simulation Works and Communicates with ROS","text":"<p> The following is the source file if you want to make edits to the diagram: Simulation Diagram Source File Download</p>"}]}